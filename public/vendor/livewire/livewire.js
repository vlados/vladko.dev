!(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self).Livewire = factory(); }(this, (() => {
  function ownKeys$1(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(((sym) => Object.getOwnPropertyDescriptor(object, sym).enumerable))), keys.push.apply(keys, symbols); } return keys; } function _objectSpread2(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(((key) => { _defineProperty(target, key, source[key]); })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(((key) => { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); })); } return target; } function _typeof(obj) { return (_typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; })(obj); } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function'); } function _defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 'value' in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor); } } function _createClass(Constructor, protoProps, staticProps) { return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor; } function _defineProperty(obj, key, value) {
    return key in obj ? Object.defineProperty(obj, key, {
      value, enumerable: !0, configurable: !0, writable: !0,
    }) : obj[key] = value, obj;
  } function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) throw new TypeError('Super expression must either be null or a function'); subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass); } function _getPrototypeOf(o) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) { return o.__proto__ || Object.getPrototypeOf(o); })(o); } function _setPrototypeOf(o, p) { return (_setPrototypeOf = Object.setPrototypeOf || function (o, p) { return o.__proto__ = p, o; })(o, p); } function _isNativeReflectConstruct() { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (() => {}))), !0; } catch (e) { return !1; } } function _assertThisInitialized(self) { if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return self; } function _possibleConstructorReturn(self, call) { return !call || typeof call !== 'object' && typeof call !== 'function' ? _assertThisInitialized(self) : call; } function _createSuper(Derived) { const hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { let result; const Super = _getPrototypeOf(Derived); if (hasNativeReflectConstruct) { const NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else result = Super.apply(this, arguments); return _possibleConstructorReturn(this, result); }; } function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); } function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); } function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); } function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); } function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } function _iterableToArray(iter) { if (typeof Symbol !== 'undefined' && iter[Symbol.iterator] != null || iter['@@iterator'] != null) return Array.from(iter); } function _iterableToArrayLimit(arr, i) { let _i = arr == null ? null : typeof Symbol !== 'undefined' && arr[Symbol.iterator] || arr['@@iterator']; if (_i != null) { let _s; let _e; const _arr = []; let _n = !0; let _d = !1; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i || _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { _n || _i.return == null || _i.return(); } finally { if (_d) throw _e; } } return _arr; } } function _unsupportedIterableToArray(o, minLen) { if (o) { if (typeof o === 'string') return _arrayLikeToArray(o, minLen); let n = Object.prototype.toString.call(o).slice(8, -1); return n === 'Object' && o.constructor && (n = o.constructor.name), n === 'Map' || n === 'Set' ? Array.from(o) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0; } } function _arrayLikeToArray(arr, len) { (len == null || len > arr.length) && (len = arr.length); for (var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i]; return arr2; } function _nonIterableSpread() { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); } function _nonIterableRest() { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); } function debounce(func, wait, immediate) { let timeout; return function () { const context = this; const args = arguments; const later = function () { timeout = null, immediate || func.apply(context, args); }; const callNow = immediate && !timeout; clearTimeout(timeout), timeout = setTimeout(later, wait), callNow && func.apply(context, args); }; } function wireDirectives(el) { return new DirectiveManager$1(el); } var DirectiveManager$1 = (function () { function DirectiveManager(el) { _classCallCheck(this, DirectiveManager), this.el = el, this.directives = this.extractTypeModifiersAndValue(); } return _createClass(DirectiveManager, [{ key: 'all', value() { return this.directives; } }, { key: 'has', value(type) { return this.directives.map(((directive) => directive.type)).includes(type); } }, { key: 'missing', value(type) { return !this.has(type); } }, { key: 'get', value(type) { return this.directives.find(((directive) => directive.type === type)); } }, { key: 'extractTypeModifiersAndValue', value() { const _this = this; return Array.from(this.el.getAttributeNames().filter(((name) => name.match(new RegExp('wire:')))).map(((name) => { const _name$replace$split2 = _toArray(name.replace(new RegExp('wire:'), '').split('.')); const type = _name$replace$split2[0]; const modifiers = _name$replace$split2.slice(1); return new Directive(type, modifiers, name, _this.el); }))); } }]), DirectiveManager; }()); var Directive = (function () { function Directive(type, modifiers, rawName, el) { _classCallCheck(this, Directive), this.type = type, this.modifiers = modifiers, this.rawName = rawName, this.el = el, this.eventContext; } return _createClass(Directive, [{ key: 'setEventContext', value(context) { this.eventContext = context; } }, { key: 'value', get() { return this.el.getAttribute(this.rawName); } }, { key: 'method', get() { return this.parseOutMethodAndParams(this.value).method; } }, { key: 'params', get() { return this.parseOutMethodAndParams(this.value).params; } }, { key: 'durationOr', value(defaultDuration) { let durationInMilliSeconds; const durationInMilliSecondsString = this.modifiers.find(((mod) => mod.match(/([0-9]+)ms/))); const durationInSecondsString = this.modifiers.find(((mod) => mod.match(/([0-9]+)s/))); return durationInMilliSecondsString ? durationInMilliSeconds = Number(durationInMilliSecondsString.replace('ms', '')) : durationInSecondsString && (durationInMilliSeconds = 1e3 * Number(durationInSecondsString.replace('s', ''))), durationInMilliSeconds || defaultDuration; } }, { key: 'parseOutMethodAndParams', value(rawMethod) { let method = rawMethod; let params = []; const methodAndParamString = method.match(/(.*?)\((.*)\)/); methodAndParamString && (method = methodAndParamString[1], params = new Function('$event', 'return (function () {\n                for (var l=arguments.length, p=new Array(l), k=0; k<l; k++) {\n                    p[k] = arguments[k];\n                }\n                return [].concat(p);\n            })('.concat(methodAndParamString[2], ')'))(this.eventContext)); return { method, params }; } }, { key: 'cardinalDirectionOr', value() { const fallback = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'right'; return this.modifiers.includes('up') ? 'up' : this.modifiers.includes('down') ? 'down' : this.modifiers.includes('left') ? 'left' : this.modifiers.includes('right') ? 'right' : fallback; } }]), Directive; }()); function walk(root, callback) { if (!1 !== callback(root)) for (let node = root.firstElementChild; node;)walk(node, callback), node = node.nextElementSibling; } function dispatch(eventName) { const event = document.createEvent('Events'); return event.initEvent(eventName, !0, !0), document.dispatchEvent(event), event; } function getCsrfToken() { let _window$livewire_toke; const tokenTag = document.head.querySelector('meta[name="csrf-token"]'); return tokenTag ? tokenTag.content : (_window$livewire_toke = window.livewire_token) !== null && void 0 !== _window$livewire_toke ? _window$livewire_toke : void 0; } function kebabCase(subject) { return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\s]/, '-').toLowerCase(); }
  /*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */const isobject = function (val) { return val != null && typeof val === 'object' && !1 === Array.isArray(val); }; const getValue = function (target, path, options) { if (isobject(options) || (options = { default: options }), !isValidObject(target)) return void 0 !== options.default ? options.default : target; typeof path === 'number' && (path = String(path)); const isArray = Array.isArray(path); const isString = typeof path === 'string'; const splitChar = options.separator || '.'; const joinChar = options.joinChar || (typeof splitChar === 'string' ? splitChar : '.'); if (!isString && !isArray) return target; if (isString && path in target) return isValid(path, target, options) ? target[path] : options.default; const segs = isArray ? path : split$1(path, splitChar, options); const len = segs.length; let idx = 0; do { let prop = segs[idx]; for (typeof prop === 'number' && (prop = String(prop)); prop && prop.slice(-1) === '\\';)prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options); if (prop in target) { if (!isValid(prop, target, options)) return options.default; target = target[prop]; } else { let hasProp = !1; let n = idx + 1; for (;n < len;) if (prop = join([prop, segs[n++]], joinChar, options), hasProp = prop in target) { if (!isValid(prop, target, options)) return options.default; target = target[prop], idx = n - 1; break; } if (!hasProp) return options.default; } } while (++idx < len && isValidObject(target)); return idx === len ? target : options.default; };
  /*!
   * get-value <https://github.com/jonschlinkert/get-value>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */function join(segs, joinChar, options) { return typeof options.join === 'function' ? options.join(segs) : segs[0] + joinChar + segs[1]; } function split$1(path, splitChar, options) { return typeof options.split === 'function' ? options.split(path) : path.split(splitChar); } function isValid(key, target, options) { return typeof options.isValid !== 'function' || options.isValid(key, target); } function isValidObject(val) { return isobject(val) || Array.isArray(val) || typeof val === 'function'; } const _default$6 = (function () { function _default(el) { const skipWatcher = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; _classCallCheck(this, _default), this.el = el, this.skipWatcher = skipWatcher, this.resolveCallback = function () {}, this.rejectCallback = function () {}, this.signature = (Math.random() + 1).toString(36).substring(8); } return _createClass(_default, [{ key: 'toId', value() { return btoa(encodeURIComponent(this.el.outerHTML)); } }, { key: 'onResolve', value(callback) { this.resolveCallback = callback; } }, { key: 'onReject', value(callback) { this.rejectCallback = callback; } }, { key: 'resolve', value(thing) { this.resolveCallback(thing); } }, { key: 'reject', value(thing) { this.rejectCallback(thing); } }]), _default; }()); const _default$5 = (function (_Action) { _inherits(_default, _Action); const _super = _createSuper(_default); function _default(event, params, el) { let _this; return _classCallCheck(this, _default), (_this = _super.call(this, el)).type = 'fireEvent', _this.payload = { id: _this.signature, event, params }, _this; } return _createClass(_default, [{ key: 'toId', value() { return btoa(encodeURIComponent(this.type, this.payload.event, JSON.stringify(this.payload.params))); } }]), _default; }(_default$6)); const MessageBus = (function () { function MessageBus() { _classCallCheck(this, MessageBus), this.listeners = {}; } return _createClass(MessageBus, [{ key: 'register', value(name, callback) { this.listeners[name] || (this.listeners[name] = []), this.listeners[name].push(callback); } }, { key: 'call', value(name) { for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)params[_key - 1] = arguments[_key]; (this.listeners[name] || []).forEach(((callback) => { callback.apply(void 0, params); })); } }, { key: 'has', value(name) { return Object.keys(this.listeners).includes(name); } }]), MessageBus; }()); const HookManager = {
    availableHooks: ['component.initialized', 'element.initialized', 'element.updating', 'element.updated', 'element.removed', 'message.sent', 'message.failed', 'message.received', 'message.processed', 'interceptWireModelSetValue', 'interceptWireModelAttachListener', 'beforeReplaceState', 'beforePushState'], bus: new MessageBus(), register(name, callback) { if (!this.availableHooks.includes(name)) throw 'Livewire: Referencing unknown hook: ['.concat(name, ']'); this.bus.register(name, callback); }, call(name) { for (var _this$bus, _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)params[_key - 1] = arguments[_key]; (_this$bus = this.bus).call.apply(_this$bus, [name].concat(params)); },
  }; const DirectiveManager = {
    directives: new MessageBus(), register(name, callback) { if (this.has(name)) throw 'Livewire: Directive already registered: ['.concat(name, ']'); this.directives.register(name, callback); }, call(name, el, directive, component) { this.directives.call(name, el, directive, component); }, has(name) { return this.directives.has(name); },
  }; const store$2 = {
    componentsById: {}, listeners: new MessageBus(), initialRenderIsFinished: !1, livewireIsInBackground: !1, livewireIsOffline: !1, sessionHasExpired: !1, sessionHasExpiredCallback: void 0, directives: DirectiveManager, hooks: HookManager, onErrorCallback() {}, components() { const _this = this; return Object.keys(this.componentsById).map(((key) => _this.componentsById[key])); }, addComponent(component) { return this.componentsById[component.id] = component; }, findComponent(id) { return this.componentsById[id]; }, getComponentsByName(name) { return this.components().filter(((component) => component.name === name)); }, hasComponent(id) { return !!this.componentsById[id]; }, tearDownComponents() { const _this2 = this; this.components().forEach(((component) => { _this2.removeComponent(component); })); }, on(event, callback) { this.listeners.register(event, callback); }, emit(event) { for (var _this$listeners, _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)params[_key - 1] = arguments[_key]; (_this$listeners = this.listeners).call.apply(_this$listeners, [event].concat(params)), this.componentsListeningForEvent(event).forEach(((component) => component.addAction(new _default$5(event, params)))); }, emitUp(el, event) { for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++)params[_key2 - 2] = arguments[_key2]; this.componentsListeningForEventThatAreTreeAncestors(el, event).forEach(((component) => component.addAction(new _default$5(event, params)))); }, emitSelf(componentId, event) { const component = this.findComponent(componentId); if (component.listeners.includes(event)) { for (var _len3 = arguments.length, params = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++)params[_key3 - 2] = arguments[_key3]; component.addAction(new _default$5(event, params)); } }, emitTo(componentName, event) { for (var _len4 = arguments.length, params = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++)params[_key4 - 2] = arguments[_key4]; const components = this.getComponentsByName(componentName); components.forEach(((component) => { component.listeners.includes(event) && component.addAction(new _default$5(event, params)); })); }, componentsListeningForEventThatAreTreeAncestors(el, event) { for (var parentIds = [], parent = el.parentElement.closest('[wire\\:id]'); parent;)parentIds.push(parent.getAttribute('wire:id')), parent = parent.parentElement.closest('[wire\\:id]'); return this.components().filter(((component) => component.listeners.includes(event) && parentIds.includes(component.id))); }, componentsListeningForEvent(event) { return this.components().filter(((component) => component.listeners.includes(event))); }, registerDirective(name, callback) { this.directives.register(name, callback); }, registerHook(name, callback) { this.hooks.register(name, callback); }, callHook(name) { for (var _this$hooks, _len5 = arguments.length, params = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++)params[_key5 - 1] = arguments[_key5]; (_this$hooks = this.hooks).call.apply(_this$hooks, [name].concat(params)); }, changeComponentId(component, newId) { const oldId = component.id; component.id = newId, component.fingerprint.id = newId, this.componentsById[newId] = component, delete this.componentsById[oldId], this.components().forEach(((component) => { const children = component.serverMemo.children || {}; Object.entries(children).forEach(((_ref) => { const _ref2 = _slicedToArray(_ref, 2); const key = _ref2[0]; const _ref2$ = _ref2[1]; const { id } = _ref2$; _ref2$.tagName, id === oldId && (children[key].id = newId); })); })); }, removeComponent(component) { component.tearDown(), delete this.componentsById[component.id]; }, onError(callback) { this.onErrorCallback = callback; }, getClosestParentId(childId, subsetOfParentIds) { const _this3 = this; const distancesByParentId = {}; subsetOfParentIds.forEach(((parentId) => { const distance = _this3.getDistanceToChild(parentId, childId); distance && (distancesByParentId[parentId] = distance); })); let closestParentId; const smallestDistance = Math.min.apply(Math, _toConsumableArray(Object.values(distancesByParentId))); return Object.entries(distancesByParentId).forEach(((_ref3) => { const _ref4 = _slicedToArray(_ref3, 2); const parentId = _ref4[0]; _ref4[1] === smallestDistance && (closestParentId = parentId); })), closestParentId; }, getDistanceToChild(parentId, childId) { const distanceMemo = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1; const parentComponent = this.findComponent(parentId); if (parentComponent) { const { childIds } = parentComponent; if (childIds.includes(childId)) return distanceMemo; for (let i = 0; i < childIds.length; i++) { const distance = this.getDistanceToChild(childIds[i], childId, distanceMemo + 1); if (distance) return distance; } } },
  }; const DOM = {
    rootComponentElements() { return Array.from(document.querySelectorAll('[wire\\:id]')); }, rootComponentElementsWithNoParents() { let node = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; node === null && (node = document); const allEls = Array.from(node.querySelectorAll('[wire\\:initial-data]')); const onlyChildEls = Array.from(node.querySelectorAll('[wire\\:initial-data] [wire\\:initial-data]')); return allEls.filter(((el) => !onlyChildEls.includes(el))); }, allModelElementsInside(root) { return Array.from(root.querySelectorAll('[wire\\:model]')); }, getByAttributeAndValue(attribute, value) { return document.querySelector('[wire\\:'.concat(attribute, '="').concat(value, '"]')); }, nextFrame(fn) { const _this = this; requestAnimationFrame((() => { requestAnimationFrame(fn.bind(_this)); })); }, closestRoot(el) { return this.closestByAttribute(el, 'id'); }, closestByAttribute(el, attribute) { const closestEl = el.closest('[wire\\:'.concat(attribute, ']')); if (!closestEl) throw '\nLivewire Error:\n\nCannot find parent element in DOM tree containing attribute: [wire:'.concat(attribute, "].\n\nUsually this is caused by Livewire's DOM-differ not being able to properly track changes.\n\nReference the following guide for common causes: https://laravel-livewire.com/docs/troubleshooting \n\nReferenced element:\n\n").concat(el.outerHTML, '\n'); return closestEl; }, isComponentRootEl(el) { return this.hasAttribute(el, 'id'); }, hasAttribute(el, attribute) { return el.hasAttribute('wire:'.concat(attribute)); }, getAttribute(el, attribute) { return el.getAttribute('wire:'.concat(attribute)); }, removeAttribute(el, attribute) { return el.removeAttribute('wire:'.concat(attribute)); }, setAttribute(el, attribute, value) { return el.setAttribute('wire:'.concat(attribute), value); }, hasFocus(el) { return el === document.activeElement; }, isInput(el) { return ['INPUT', 'TEXTAREA', 'SELECT'].includes(el.tagName.toUpperCase()); }, isTextInput(el) { return ['INPUT', 'TEXTAREA'].includes(el.tagName.toUpperCase()) && !['checkbox', 'radio'].includes(el.type); }, valueFromInput(el, component) { if (el.type === 'checkbox') { const modelName = wireDirectives(el).get('model').value; const modelValue = component.deferredActions[modelName] ? component.deferredActions[modelName].payload.value : getValue(component.data, modelName); return Array.isArray(modelValue) ? this.mergeCheckboxValueIntoArray(el, modelValue) : !!el.checked && (el.getAttribute('value') || !0); } return el.tagName === 'SELECT' && el.multiple ? this.getSelectValues(el) : el.value; }, mergeCheckboxValueIntoArray(el, arrayValue) { return el.checked ? arrayValue.includes(el.value) ? arrayValue : arrayValue.concat(el.value) : arrayValue.filter(((item) => item != el.value)); }, setInputValueFromModel(el, component) { const modelString = wireDirectives(el).get('model').value; const modelValue = getValue(component.data, modelString); el.tagName.toLowerCase() === 'input' && el.type === 'file' || this.setInputValue(el, modelValue); }, setInputValue(el, value) { if (store$2.callHook('interceptWireModelSetValue', value, el), el.type === 'radio')el.checked = el.value == value; else if (el.type === 'checkbox') if (Array.isArray(value)) { let valueFound = !1; value.forEach(((val) => { val == el.value && (valueFound = !0); })), el.checked = valueFound; } else el.checked = !!value; else el.tagName === 'SELECT' ? this.updateSelect(el, value) : (value = void 0 === value ? '' : value, el.value = value); }, getSelectValues(el) { return Array.from(el.options).filter(((option) => option.selected)).map(((option) => option.value || option.text)); }, updateSelect(el, value) { const arrayWrappedValue = [].concat(value).map(((value) => `${value}`)); Array.from(el.options).forEach(((option) => { option.selected = arrayWrappedValue.includes(option.value); })); },
  }; const { ceil } = Math; const { floor } = Math; const toInteger = function (argument) { return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument); }; const requireObjectCoercible = function (it) { if (it == null) throw TypeError(`Can't call method on ${it}`); return it; }; const createMethod$3 = function (CONVERT_TO_STRING) { return function ($this, pos) { let first; let second; const S = String(requireObjectCoercible($this)); const position = toInteger(pos); const size = S.length; return position < 0 || position >= size ? CONVERT_TO_STRING ? '' : void 0 : (first = S.charCodeAt(position)) < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : second - 56320 + (first - 55296 << 10) + 65536; }; }; const stringMultibyte = { codeAt: createMethod$3(!1), charAt: createMethod$3(!0) }; const commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; function createCommonjsModule(fn, basedir, module) { return fn(module = { path: basedir, exports: {}, require(path, base) { return commonjsRequire(path, base == null ? module.path : base); } }, module.exports), module.exports; } function commonjsRequire() { throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs'); } const check = function (it) { return it && it.Math == Math && it; }; const global_1 = check(typeof globalThis === 'object' && globalThis) || check(typeof window === 'object' && window) || check(typeof self === 'object' && self) || check(typeof commonjsGlobal === 'object' && commonjsGlobal) || (function () { return this; }()) || Function('return this')(); const fails = function (exec) { try { return !!exec(); } catch (error) { return !0; } }; const descriptors = !fails((() => Object.defineProperty({}, 1, { get() { return 7; } })[1] != 7)); const isObject = function (it) { return typeof it === 'object' ? it !== null : typeof it === 'function'; }; const document$3 = global_1.document; const EXISTS = isObject(document$3) && isObject(document$3.createElement); const documentCreateElement = function (it) { return EXISTS ? document$3.createElement(it) : {}; }; const ie8DomDefine = !descriptors && !fails((() => Object.defineProperty(documentCreateElement('div'), 'a', { get() { return 7; } }).a != 7)); const anObject = function (it) { if (!isObject(it)) throw TypeError(`${String(it)} is not an object`); return it; }; const toPrimitive = function (input, PREFERRED_STRING) { if (!isObject(input)) return input; let fn; let val; if (PREFERRED_STRING && typeof (fn = input.toString) === 'function' && !isObject(val = fn.call(input))) return val; if (typeof (fn = input.valueOf) === 'function' && !isObject(val = fn.call(input))) return val; if (!PREFERRED_STRING && typeof (fn = input.toString) === 'function' && !isObject(val = fn.call(input))) return val; throw TypeError("Can't convert object to primitive value"); }; const $defineProperty = Object.defineProperty; const f$5 = descriptors ? $defineProperty : function (O, P, Attributes) { if (anObject(O), P = toPrimitive(P, !0), anObject(Attributes), ie8DomDefine) try { return $defineProperty(O, P, Attributes); } catch (error) {} if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported'); return 'value' in Attributes && (O[P] = Attributes.value), O; }; const objectDefineProperty = { f: f$5 }; const createPropertyDescriptor = function (bitmap, value) {
    return {
      enumerable: !(1 & bitmap), configurable: !(2 & bitmap), writable: !(4 & bitmap), value,
    };
  }; const createNonEnumerableProperty = descriptors ? function (object, key, value) { return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value)); } : function (object, key, value) { return object[key] = value, object; }; const setGlobal = function (key, value) { try { createNonEnumerableProperty(global_1, key, value); } catch (error) { global_1[key] = value; } return value; }; const SHARED = '__core-js_shared__'; const store$1 = global_1[SHARED] || setGlobal(SHARED, {}); const sharedStore = store$1; const functionToString = Function.toString; typeof sharedStore.inspectSource !== 'function' && (sharedStore.inspectSource = function (it) { return functionToString.call(it); }); const { inspectSource } = sharedStore; const WeakMap$1 = global_1.WeakMap; const nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1)); const toObject = function (argument) { return Object(requireObjectCoercible(argument)); }; const { hasOwnProperty } = {}; const has$1 = Object.hasOwn || function (it, key) { return hasOwnProperty.call(toObject(it), key); }; const shared = createCommonjsModule(((module) => { (module.exports = function (key, value) { return sharedStore[key] || (sharedStore[key] = void 0 !== value ? value : {}); })('versions', []).push({ version: '3.15.2', mode: 'global', copyright: '© 2021 Denis Pushkarev (zloirock.ru)' }); })); let id = 0; const postfix = Math.random(); const uid = function (key) { return `Symbol(${String(void 0 === key ? '' : key)})_${(++id + postfix).toString(36)}`; }; const keys = shared('keys'); const sharedKey = function (key) { return keys[key] || (keys[key] = uid(key)); }; const hiddenKeys$1 = {}; const OBJECT_ALREADY_INITIALIZED = 'Object already initialized'; const { WeakMap } = global_1; let set$1; let get; let has; const enforce = function (it) { return has(it) ? get(it) : set$1(it, {}); }; const
    getterFor = function (TYPE) { return function (it) { let state; if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError(`Incompatible receiver, ${TYPE} required`); return state; }; }; if (nativeWeakMap || sharedStore.state) { const store = sharedStore.state || (sharedStore.state = new WeakMap()); const wmget = store.get; const wmhas = store.has; const wmset = store.set; set$1 = function (it, metadata) { if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED); return metadata.facade = it, wmset.call(store, it, metadata), metadata; }, get = function (it) { return wmget.call(store, it) || {}; }, has = function (it) { return wmhas.call(store, it); }; } else { const STATE = sharedKey('state'); hiddenKeys$1[STATE] = !0, set$1 = function (it, metadata) { if (has$1(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED); return metadata.facade = it, createNonEnumerableProperty(it, STATE, metadata), metadata; }, get = function (it) { return has$1(it, STATE) ? it[STATE] : {}; }, has = function (it) { return has$1(it, STATE); }; } const internalState = {
    set: set$1, get, has, enforce, getterFor,
  }; const $propertyIsEnumerable = {}.propertyIsEnumerable; const getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor; const NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable.call({ 1: 2 }, 1); const f$4 = NASHORN_BUG ? function (V) { const descriptor = getOwnPropertyDescriptor$3(this, V); return !!descriptor && descriptor.enumerable; } : $propertyIsEnumerable; const objectPropertyIsEnumerable = { f: f$4 }; const { toString } = {}; const classofRaw = function (it) { return toString.call(it).slice(8, -1); }; const { split } = ''; const indexedObject = fails((() => !Object('z').propertyIsEnumerable(0))) ? function (it) { return classofRaw(it) == 'String' ? split.call(it, '') : Object(it); } : Object; const toIndexedObject = function (it) { return indexedObject(requireObjectCoercible(it)); }; const $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; const f$3 = descriptors ? $getOwnPropertyDescriptor : function (O, P) { if (O = toIndexedObject(O), P = toPrimitive(P, !0), ie8DomDefine) try { return $getOwnPropertyDescriptor(O, P); } catch (error) {} if (has$1(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]); }; const objectGetOwnPropertyDescriptor = { f: f$3 }; const redefine = createCommonjsModule(((module) => { const getInternalState = internalState.get; const enforceInternalState = internalState.enforce; const TEMPLATE = String(String).split('String'); (module.exports = function (O, key, value, options) { let state; const unsafe = !!options && !!options.unsafe; let simple = !!options && !!options.enumerable; const noTargetGet = !!options && !!options.noTargetGet; typeof value === 'function' && (typeof key !== 'string' || has$1(value, 'name') || createNonEnumerableProperty(value, 'name', key), (state = enforceInternalState(value)).source || (state.source = TEMPLATE.join(typeof key === 'string' ? key : ''))), O !== global_1 ? (unsafe ? !noTargetGet && O[key] && (simple = !0) : delete O[key], simple ? O[key] = value : createNonEnumerableProperty(O, key, value)) : simple ? O[key] = value : setGlobal(key, value); })(Function.prototype, 'toString', (function () { return typeof this === 'function' && getInternalState(this).source || inspectSource(this); })); })); const path = global_1; const aFunction$1 = function (variable) { return typeof variable === 'function' ? variable : void 0; }; const getBuiltIn = function (namespace, method) { return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method]; }; const min$2 = Math.min; const toLength = function (argument) { return argument > 0 ? min$2(toInteger(argument), 9007199254740991) : 0; }; const { max } = Math; const min$1 = Math.min; const toAbsoluteIndex = function (index, length) { const integer = toInteger(index); return integer < 0 ? max(integer + length, 0) : min$1(integer, length); }; const createMethod$2 = function (IS_INCLUDES) { return function ($this, el, fromIndex) { let value; const O = toIndexedObject($this); const length = toLength(O.length); let index = toAbsoluteIndex(fromIndex, length); if (IS_INCLUDES && el != el) { for (;length > index;) if ((value = O[index++]) != value) return !0; } else for (;length > index; index++) if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0; return !IS_INCLUDES && -1; }; }; const arrayIncludes = { includes: createMethod$2(!0), indexOf: createMethod$2(!1) }; const { indexOf } = arrayIncludes; const objectKeysInternal = function (object, names) { let key; const O = toIndexedObject(object); let i = 0; const result = []; for (key in O)!has$1(hiddenKeys$1, key) && has$1(O, key) && result.push(key); for (;names.length > i;)has$1(O, key = names[i++]) && (~indexOf(result, key) || result.push(key)); return result; }; const enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf']; const hiddenKeys = enumBugKeys.concat('length', 'prototype'); const f$2 = Object.getOwnPropertyNames || function (O) { return objectKeysInternal(O, hiddenKeys); }; const objectGetOwnPropertyNames = { f: f$2 }; const f$1 = Object.getOwnPropertySymbols; const objectGetOwnPropertySymbols = { f: f$1 }; const ownKeys = getBuiltIn('Reflect', 'ownKeys') || function (it) { const keys = objectGetOwnPropertyNames.f(anObject(it)); const getOwnPropertySymbols = objectGetOwnPropertySymbols.f; return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys; }; const copyConstructorProperties = function (target, source) { for (let keys = ownKeys(source), defineProperty = objectDefineProperty.f, getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f, i = 0; i < keys.length; i++) { const key = keys[i]; has$1(target, key) || defineProperty(target, key, getOwnPropertyDescriptor(source, key)); } }; const replacement = /#|\.prototype\./; const isForced = function (feature, detection) { const value = data[normalize(feature)]; return value == POLYFILL || value != NATIVE && (typeof detection === 'function' ? fails(detection) : !!detection); }; var normalize = isForced.normalize = function (string) { return String(string).replace(replacement, '.').toLowerCase(); }; var data = isForced.data = {}; var NATIVE = isForced.NATIVE = 'N'; var POLYFILL = isForced.POLYFILL = 'P'; const isForced_1 = isForced; const getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f; const _export = function (options, source) { let target; let key; let targetProperty; let sourceProperty; let descriptor; const TARGET = options.target; const GLOBAL = options.global; const STATIC = options.stat; if (target = GLOBAL ? global_1 : STATIC ? global_1[TARGET] || setGlobal(TARGET, {}) : (global_1[TARGET] || {}).prototype) for (key in source) { if (sourceProperty = source[key], targetProperty = options.noTargetGet ? (descriptor = getOwnPropertyDescriptor$2(target, key)) && descriptor.value : target[key], !isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced) && void 0 !== targetProperty) { if (typeof sourceProperty === typeof targetProperty) continue; copyConstructorProperties(sourceProperty, targetProperty); }(options.sham || targetProperty && targetProperty.sham) && createNonEnumerableProperty(sourceProperty, 'sham', !0), redefine(target, key, sourceProperty, options); } }; const correctPrototypeGetter = !fails((() => { function F() {} return F.prototype.constructor = null, Object.getPrototypeOf(new F()) !== F.prototype; })); const IE_PROTO$1 = sharedKey('IE_PROTO'); const ObjectPrototype = Object.prototype; const objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) { return O = toObject(O), has$1(O, IE_PROTO$1) ? O[IE_PROTO$1] : typeof O.constructor === 'function' && O instanceof O.constructor ? O.constructor.prototype : O instanceof Object ? ObjectPrototype : null; }; const engineUserAgent = getBuiltIn('navigator', 'userAgent') || ''; const process$3 = global_1.process; const versions = process$3 && process$3.versions; const v8 = versions && versions.v8; let match; let version; v8 ? (match = v8.split('.'), version = match[0] < 4 ? 1 : match[0] + match[1]) : engineUserAgent && (match = engineUserAgent.match(/Edge\/(\d+)/), (!match || match[1] >= 74) && (match = engineUserAgent.match(/Chrome\/(\d+)/), match && (version = match[1]))); const engineV8Version = version && +version; const nativeSymbol = !!Object.getOwnPropertySymbols && !fails((() => { const symbol = Symbol(); return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && engineV8Version && engineV8Version < 41; })); const useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator === 'symbol'; const WellKnownSymbolsStore = shared('wks'); const Symbol$1 = global_1.Symbol; const createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid; const wellKnownSymbol = function (name) { return has$1(WellKnownSymbolsStore, name) && (nativeSymbol || typeof WellKnownSymbolsStore[name] === 'string') || (nativeSymbol && has$1(Symbol$1, name) ? WellKnownSymbolsStore[name] = Symbol$1[name] : WellKnownSymbolsStore[name] = createWellKnownSymbol(`Symbol.${name}`)), WellKnownSymbolsStore[name]; }; const ITERATOR$5 = wellKnownSymbol('iterator'); let BUGGY_SAFARI_ITERATORS$1 = !1; const returnThis$2 = function () { return this; }; let IteratorPrototype$2; let PrototypeOfArrayIteratorPrototype; let arrayIterator; [].keys && (arrayIterator = [].keys(), 'next' in arrayIterator ? (PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator)), PrototypeOfArrayIteratorPrototype !== Object.prototype && (IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype)) : BUGGY_SAFARI_ITERATORS$1 = !0); const NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == null || fails((() => { const test = {}; return IteratorPrototype$2[ITERATOR$5].call(test) !== test; })); NEW_ITERATOR_PROTOTYPE && (IteratorPrototype$2 = {}), has$1(IteratorPrototype$2, ITERATOR$5) || createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$5, returnThis$2); const iteratorsCore = { IteratorPrototype: IteratorPrototype$2, BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1 }; const objectKeys = Object.keys || function (O) { return objectKeysInternal(O, enumBugKeys); }; const objectDefineProperties = descriptors ? Object.defineProperties : function (O, Properties) { anObject(O); for (var key, keys = objectKeys(Properties), { length } = keys, index = 0; length > index;)objectDefineProperty.f(O, key = keys[index++], Properties[key]); return O; }; const html = getBuiltIn('document', 'documentElement'); const GT = '>'; const LT = '<'; const PROTOTYPE = 'prototype'; const SCRIPT = 'script'; const IE_PROTO = sharedKey('IE_PROTO'); const EmptyConstructor = function () {}; const scriptTag = function (content) { return `${LT + SCRIPT + GT + content + LT}/${SCRIPT}${GT}`; }; const NullProtoObjectViaActiveX = function (activeXDocument) { activeXDocument.write(scriptTag('')), activeXDocument.close(); const temp = activeXDocument.parentWindow.Object; return activeXDocument = null, temp; }; const NullProtoObjectViaIFrame = function () { let iframeDocument; const iframe = documentCreateElement('iframe'); const JS = `java${SCRIPT}:`; return iframe.style.display = 'none', html.appendChild(iframe), iframe.src = String(JS), (iframeDocument = iframe.contentWindow.document).open(), iframeDocument.write(scriptTag('document.F=Object')), iframeDocument.close(), iframeDocument.F; }; let activeXDocument; var NullProtoObject = function () { try { activeXDocument = document.domain && new ActiveXObject('htmlfile'); } catch (error) {}NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame(); for (let { length } = enumBugKeys; length--;) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]]; return NullProtoObject(); }; hiddenKeys$1[IE_PROTO] = !0; const objectCreate = Object.create || function (O, Properties) { let result; return O !== null ? (EmptyConstructor[PROTOTYPE] = anObject(O), result = new EmptyConstructor(), EmptyConstructor[PROTOTYPE] = null, result[IE_PROTO] = O) : result = NullProtoObject(), void 0 === Properties ? result : objectDefineProperties(result, Properties); }; const defineProperty$1 = objectDefineProperty.f; const TO_STRING_TAG$3 = wellKnownSymbol('toStringTag'); const setToStringTag = function (it, TAG, STATIC) { it && !has$1(it = STATIC ? it : it.prototype, TO_STRING_TAG$3) && defineProperty$1(it, TO_STRING_TAG$3, { configurable: !0, value: TAG }); }; const iterators = {}; const IteratorPrototype$1 = iteratorsCore.IteratorPrototype; const returnThis$1 = function () { return this; }; const createIteratorConstructor = function (IteratorConstructor, NAME, next) { const TO_STRING_TAG = `${NAME} Iterator`; return IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) }), setToStringTag(IteratorConstructor, TO_STRING_TAG, !1), iterators[TO_STRING_TAG] = returnThis$1, IteratorConstructor; }; const aPossiblePrototype = function (it) { if (!isObject(it) && it !== null) throw TypeError(`Can't set ${String(it)} as a prototype`); return it; }; const objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? (function () { let setter; let CORRECT_SETTER = !1; const test = {}; try { (setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set).call(test, []), CORRECT_SETTER = test instanceof Array; } catch (error) {} return function (O, proto) { return anObject(O), aPossiblePrototype(proto), CORRECT_SETTER ? setter.call(O, proto) : O.__proto__ = proto, O; }; }()) : void 0); const { IteratorPrototype } = iteratorsCore; const { BUGGY_SAFARI_ITERATORS } = iteratorsCore; const ITERATOR$4 = wellKnownSymbol('iterator'); const KEYS = 'keys'; const VALUES = 'values'; const ENTRIES = 'entries'; const returnThis = function () { return this; }; const defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) { createIteratorConstructor(IteratorConstructor, NAME, next); let CurrentIteratorPrototype; let methods; let KEY; const getIterationMethod = function (KIND) { if (KIND === DEFAULT && defaultIterator) return defaultIterator; if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND]; switch (KIND) { case KEYS: case VALUES: case ENTRIES: return function () { return new IteratorConstructor(this, KIND); }; } return function () { return new IteratorConstructor(this); }; }; const TO_STRING_TAG = `${NAME} Iterator`; let INCORRECT_VALUES_NAME = !1; var IterablePrototype = Iterable.prototype; const nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT]; var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT); const anyNativeIterator = NAME == 'Array' && IterablePrototype.entries || nativeIterator; if (anyNativeIterator && (CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable())), IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next && (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype && (objectSetPrototypeOf ? objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype) : typeof CurrentIteratorPrototype[ITERATOR$4] !== 'function' && createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis)), setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, !0))), DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES && (INCORRECT_VALUES_NAME = !0, defaultIterator = function () { return nativeIterator.call(this); }), IterablePrototype[ITERATOR$4] !== defaultIterator && createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator), iterators[NAME] = defaultIterator, DEFAULT) if (methods = { values: getIterationMethod(VALUES), keys: IS_SET ? defaultIterator : getIterationMethod(KEYS), entries: getIterationMethod(ENTRIES) }, FORCED) for (KEY in methods)(BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) && redefine(IterablePrototype, KEY, methods[KEY]); else _export({ target: NAME, proto: !0, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods); return methods; }; const { charAt } = stringMultibyte; const STRING_ITERATOR = 'String Iterator'; const setInternalState$2 = internalState.set; const getInternalState$2 = internalState.getterFor(STRING_ITERATOR); defineIterator(String, 'String', (function (iterated) { setInternalState$2(this, { type: STRING_ITERATOR, string: String(iterated), index: 0 }); }), (function () { let point; const state = getInternalState$2(this); const { string } = state; const { index } = state; return index >= string.length ? { value: void 0, done: !0 } : (point = charAt(string, index), state.index += point.length, { value: point, done: !1 }); })); const aFunction = function (it) { if (typeof it !== 'function') throw TypeError(`${String(it)} is not a function`); return it; }; const functionBindContext = function (fn, that, length) { if (aFunction(fn), void 0 === that) return fn; switch (length) { case 0: return function () { return fn.call(that); }; case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function () { return fn.apply(that, arguments); }; }; const iteratorClose = function (iterator) { const returnMethod = iterator.return; if (void 0 !== returnMethod) return anObject(returnMethod.call(iterator)).value; }; const callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) { try { return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); } catch (error) { throw iteratorClose(iterator), error; } }; const ITERATOR$3 = wellKnownSymbol('iterator'); const ArrayPrototype$1 = Array.prototype; const isArrayIteratorMethod = function (it) { return void 0 !== it && (iterators.Array === it || ArrayPrototype$1[ITERATOR$3] === it); }; const createProperty = function (object, key, value) { const propertyKey = toPrimitive(key); propertyKey in object ? objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value)) : object[propertyKey] = value; }; const TO_STRING_TAG$2 = wellKnownSymbol('toStringTag'); const test = {}; test[TO_STRING_TAG$2] = 'z'; const toStringTagSupport = String(test) === '[object z]'; const TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); const CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments'; const tryGet = function (it, key) { try { return it[key]; } catch (error) {} }; const classof = toStringTagSupport ? classofRaw : function (it) { let O; let tag; let result; return void 0 === it ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) === 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && typeof O.callee === 'function' ? 'Arguments' : result; }; const ITERATOR$2 = wellKnownSymbol('iterator'); const getIteratorMethod = function (it) { if (it != null) return it[ITERATOR$2] || it['@@iterator'] || iterators[classof(it)]; }; const arrayFrom = function (arrayLike) { let length; let result; let step; let iterator; let next; let value; const O = toObject(arrayLike); const C = typeof this === 'function' ? this : Array; const argumentsLength = arguments.length; let mapfn = argumentsLength > 1 ? arguments[1] : void 0; const mapping = void 0 !== mapfn; const iteratorMethod = getIteratorMethod(O); let index = 0; if (mapping && (mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2)), iteratorMethod == null || C == Array && isArrayIteratorMethod(iteratorMethod)) for (result = new C(length = toLength(O.length)); length > index; index++)value = mapping ? mapfn(O[index], index) : O[index], createProperty(result, index, value); else for (next = (iterator = iteratorMethod.call(O)).next, result = new C(); !(step = next.call(iterator)).done; index++)value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], !0) : step.value, createProperty(result, index, value); return result.length = index, result; }; const ITERATOR$1 = wellKnownSymbol('iterator'); let SAFE_CLOSING = !1; try { let called = 0; const iteratorWithReturn = { next() { return { done: !!called++ }; }, return() { SAFE_CLOSING = !0; } }; iteratorWithReturn[ITERATOR$1] = function () { return this; }, Array.from(iteratorWithReturn, (() => { throw 2; })); } catch (error) {} const checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) { if (!SKIP_CLOSING && !SAFE_CLOSING) return !1; let ITERATION_SUPPORT = !1; try { const object = {}; object[ITERATOR$1] = function () { return { next() { return { done: ITERATION_SUPPORT = !0 }; } }; }, exec(object); } catch (error) {} return ITERATION_SUPPORT; }; const INCORRECT_ITERATION$1 = !checkCorrectnessOfIteration(((iterable) => { Array.from(iterable); })); _export({ target: 'Array', stat: !0, forced: INCORRECT_ITERATION$1 }, { from: arrayFrom }), path.Array.from; const UNSCOPABLES = wellKnownSymbol('unscopables'); const ArrayPrototype = Array.prototype; ArrayPrototype[UNSCOPABLES] == null && objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, { configurable: !0, value: objectCreate(null) }); const addToUnscopables = function (key) { ArrayPrototype[UNSCOPABLES][key] = !0; }; const $includes = arrayIncludes.includes; _export({ target: 'Array', proto: !0 }, { includes(el) { return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0); } }), addToUnscopables('includes'); const { call } = Function; const
    entryUnbind = function (CONSTRUCTOR, METHOD, length) { return functionBindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length); }; entryUnbind('Array', 'includes'); const isArray = Array.isArray || function (arg) { return classofRaw(arg) == 'Array'; }; var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) { for (var element, targetIndex = start, sourceIndex = 0, mapFn = !!mapper && functionBindContext(mapper, thisArg, 3); sourceIndex < sourceLen;) { if (sourceIndex in source) { if (element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex], depth > 0 && isArray(element))targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1; else { if (targetIndex >= 9007199254740991) throw TypeError('Exceed the acceptable array length'); target[targetIndex] = element; }targetIndex++; }sourceIndex++; } return targetIndex; }; const flattenIntoArray_1 = flattenIntoArray; const SPECIES$3 = wellKnownSymbol('species'); const arraySpeciesCreate = function (originalArray, length) { let C; return isArray(originalArray) && (typeof (C = originalArray.constructor) !== 'function' || C !== Array && !isArray(C.prototype) ? isObject(C) && (C = C[SPECIES$3]) === null && (C = void 0) : C = void 0), new (void 0 === C ? Array : C)(length === 0 ? 0 : length); }; _export({ target: 'Array', proto: !0 }, { flat() { const depthArg = arguments.length ? arguments[0] : void 0; const O = toObject(this); const sourceLen = toLength(O.length); const A = arraySpeciesCreate(O, 0); return A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, void 0 === depthArg ? 1 : toInteger(depthArg)), A; } }), addToUnscopables('flat'), entryUnbind('Array', 'flat'); const { push } = []; const createMethod$1 = function (TYPE) { const IS_MAP = TYPE == 1; const IS_FILTER = TYPE == 2; const IS_SOME = TYPE == 3; const IS_EVERY = TYPE == 4; const IS_FIND_INDEX = TYPE == 6; const IS_FILTER_OUT = TYPE == 7; const NO_HOLES = TYPE == 5 || IS_FIND_INDEX; return function ($this, callbackfn, that, specificCreate) { for (var value, result, O = toObject($this), self = indexedObject(O), boundFunction = functionBindContext(callbackfn, that, 3), length = toLength(self.length), index = 0, create = specificCreate || arraySpeciesCreate, target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : void 0; length > index; index++) if ((NO_HOLES || index in self) && (result = boundFunction(value = self[index], index, O), TYPE)) if (IS_MAP)target[index] = result; else if (result) switch (TYPE) { case 3: return !0; case 5: return value; case 6: return index; case 2: push.call(target, value); } else switch (TYPE) { case 4: return !1; case 7: push.call(target, value); } return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target; }; }; const arrayIteration = {
    forEach: createMethod$1(0), map: createMethod$1(1), filter: createMethod$1(2), some: createMethod$1(3), every: createMethod$1(4), find: createMethod$1(5), findIndex: createMethod$1(6), filterOut: createMethod$1(7),
  }; const $find = arrayIteration.find; const FIND = 'find'; let
    SKIPS_HOLES = !0; FIND in [] && Array(1)[FIND]((() => { SKIPS_HOLES = !1; })), _export({ target: 'Array', proto: !0, forced: SKIPS_HOLES }, { find(callbackfn) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0); } }), addToUnscopables(FIND), entryUnbind('Array', 'find'); const $assign = Object.assign; const { defineProperty } = Object; const objectAssign = !$assign || fails((() => { if (descriptors && ({ b: 1, ...$assign(defineProperty({}, 'a', { enumerable: !0, get() { defineProperty(this, 'b', { value: 3, enumerable: !1 }); } }), { b: 2 }) }).b !== 1) return !0; const A = {}; const B = {}; const symbol = Symbol(); return A[symbol] = 7, 'abcdefghijklmnopqrst'.split('').forEach(((chr) => { B[chr] = chr; })), ({ ...A })[symbol] != 7 || objectKeys({ ...B }).join('') != 'abcdefghijklmnopqrst'; })) ? function (target, source) { for (var T = toObject(target), argumentsLength = arguments.length, index = 1, getOwnPropertySymbols = objectGetOwnPropertySymbols.f, propertyIsEnumerable = objectPropertyIsEnumerable.f; argumentsLength > index;) for (var key, S = indexedObject(arguments[index++]), keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S), { length } = keys, j = 0; length > j;)key = keys[j++], descriptors && !propertyIsEnumerable.call(S, key) || (T[key] = S[key]); return T; } : $assign; _export({ target: 'Object', stat: !0, forced: Object.assign !== objectAssign }, { assign: objectAssign }), path.Object.assign; const propertyIsEnumerable = objectPropertyIsEnumerable.f; const createMethod = function (TO_ENTRIES) { return function (it) { for (var key, O = toIndexedObject(it), keys = objectKeys(O), { length } = keys, i = 0, result = []; length > i;)key = keys[i++], descriptors && !propertyIsEnumerable.call(O, key) || result.push(TO_ENTRIES ? [key, O[key]] : O[key]); return result; }; }; const objectToArray = { entries: createMethod(!0), values: createMethod(!1) }; const $entries = objectToArray.entries; _export({ target: 'Object', stat: !0 }, { entries(O) { return $entries(O); } }), path.Object.entries; const $values = objectToArray.values; _export({ target: 'Object', stat: !0 }, { values(O) { return $values(O); } }), path.Object.values; const Result = function (stopped, result) { this.stopped = stopped, this.result = result; }; const iterate = function (iterable, unboundFunction, options) { let iterator; let iterFn; let index; let length; let result; let next; let step; const that = options && options.that; const AS_ENTRIES = !(!options || !options.AS_ENTRIES); const IS_ITERATOR = !(!options || !options.IS_ITERATOR); const INTERRUPTED = !(!options || !options.INTERRUPTED); const fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED); const stop = function (condition) { return iterator && iteratorClose(iterator), new Result(!0, condition); }; const callFn = function (value) { return AS_ENTRIES ? (anObject(value), INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1])) : INTERRUPTED ? fn(value, stop) : fn(value); }; if (IS_ITERATOR)iterator = iterable; else { if (typeof (iterFn = getIteratorMethod(iterable)) !== 'function') throw TypeError('Target is not iterable'); if (isArrayIteratorMethod(iterFn)) { for (index = 0, length = toLength(iterable.length); length > index; index++) if ((result = callFn(iterable[index])) && result instanceof Result) return result; return new Result(!1); }iterator = iterFn.call(iterable); } for (next = iterator.next; !(step = next.call(iterator)).done;) { try { result = callFn(step.value); } catch (error) { throw iteratorClose(iterator), error; } if (typeof result === 'object' && result && result instanceof Result) return result; } return new Result(!1); }; var $AggregateError = function (errors, message) { let that = this; if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message); objectSetPrototypeOf && (that = objectSetPrototypeOf(new Error(void 0), objectGetPrototypeOf(that))), void 0 !== message && createNonEnumerableProperty(that, 'message', String(message)); const errorsArray = []; return iterate(errors, errorsArray.push, { that: errorsArray }), createNonEnumerableProperty(that, 'errors', errorsArray), that; }; $AggregateError.prototype = objectCreate(Error.prototype, { constructor: createPropertyDescriptor(5, $AggregateError), message: createPropertyDescriptor(5, ''), name: createPropertyDescriptor(5, 'AggregateError') }), _export({ global: !0 }, { AggregateError: $AggregateError }); const objectToString = toStringTagSupport ? {}.toString : function () { return `[object ${classof(this)}]`; }; toStringTagSupport || redefine(Object.prototype, 'toString', objectToString, { unsafe: !0 }); const nativePromiseConstructor = global_1.Promise; const redefineAll = function (target, src, options) { for (const key in src)redefine(target, key, src[key], options); return target; }; const SPECIES$2 = wellKnownSymbol('species'); const setSpecies = function (CONSTRUCTOR_NAME) { const Constructor = getBuiltIn(CONSTRUCTOR_NAME); const defineProperty = objectDefineProperty.f; descriptors && Constructor && !Constructor[SPECIES$2] && defineProperty(Constructor, SPECIES$2, { configurable: !0, get() { return this; } }); }; const anInstance = function (it, Constructor, name) { if (!(it instanceof Constructor)) throw TypeError(`Incorrect ${name ? `${name} ` : ''}invocation`); return it; }; const SPECIES$1 = wellKnownSymbol('species'); const speciesConstructor = function (O, defaultConstructor) { let S; const C = anObject(O).constructor; return void 0 === C || (S = anObject(C)[SPECIES$1]) == null ? defaultConstructor : aFunction(S); }; const engineIsIos = /(?:iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent); const engineIsNode = classofRaw(global_1.process) == 'process'; const { location } = global_1; let set = global_1.setImmediate; let clear = global_1.clearImmediate; const process$2 = global_1.process; const { MessageChannel } = global_1; const { Dispatch } = global_1; let counter = 0; const queue = {}; const ONREADYSTATECHANGE = 'onreadystatechange'; let defer; let channel; let port; const run = function (id) { if (queue.hasOwnProperty(id)) { const fn = queue[id]; delete queue[id], fn(); } }; const runner = function (id) { return function () { run(id); }; }; const listener = function (event) { run(event.data); }; const post = function (id) { global_1.postMessage(`${id}`, `${location.protocol}//${location.host}`); }; set && clear || (set = function (fn) { for (var args = [], i = 1; arguments.length > i;)args.push(arguments[i++]); return queue[++counter] = function () { (typeof fn === 'function' ? fn : Function(fn)).apply(void 0, args); }, defer(counter), counter; }, clear = function (id) { delete queue[id]; }, engineIsNode ? defer = function (id) { process$2.nextTick(runner(id)); } : Dispatch && Dispatch.now ? defer = function (id) { Dispatch.now(runner(id)); } : MessageChannel && !engineIsIos ? (channel = new MessageChannel(), port = channel.port2, channel.port1.onmessage = listener, defer = functionBindContext(port.postMessage, port, 1)) : global_1.addEventListener && typeof postMessage === 'function' && !global_1.importScripts && location && location.protocol !== 'file:' && !fails(post) ? (defer = post, global_1.addEventListener('message', listener, !1)) : defer = ONREADYSTATECHANGE in documentCreateElement('script') ? function (id) { html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () { html.removeChild(this), run(id); }; } : function (id) { setTimeout(runner(id), 0); }); const task$1 = { set, clear }; const engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent); const getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f; const macrotask = task$1.set; const MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver; const document$2 = global_1.document; const process$1 = global_1.process; const Promise$1 = global_1.Promise; const queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global_1, 'queueMicrotask'); const queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value; let flush; let head; let last; let notify$1; let toggle; let node; let promise; let then; queueMicrotask || (flush = function () { let parent; let fn; for (engineIsNode && (parent = process$1.domain) && parent.exit(); head;) { fn = head.fn, head = head.next; try { fn(); } catch (error) { throw head ? notify$1() : last = void 0, error; } }last = void 0, parent && parent.enter(); }, engineIsIos || engineIsNode || engineIsWebosWebkit || !MutationObserver || !document$2 ? Promise$1 && Promise$1.resolve ? (promise = Promise$1.resolve(void 0), promise.constructor = Promise$1, then = promise.then, notify$1 = function () { then.call(promise, flush); }) : notify$1 = engineIsNode ? function () { process$1.nextTick(flush); } : function () { macrotask.call(global_1, flush); } : (toggle = !0, node = document$2.createTextNode(''), new MutationObserver(flush).observe(node, { characterData: !0 }), notify$1 = function () { node.data = toggle = !toggle; })); const microtask = queueMicrotask || function (fn) { const task = { fn, next: void 0 }; last && (last.next = task), head || (head = task, notify$1()), last = task; }; const PromiseCapability = function (C) { let resolve; let reject; this.promise = new C((($$resolve, $$reject) => { if (void 0 !== resolve || void 0 !== reject) throw TypeError('Bad Promise constructor'); resolve = $$resolve, reject = $$reject; })), this.resolve = aFunction(resolve), this.reject = aFunction(reject); }; const f = function (C) { return new PromiseCapability(C); }; const newPromiseCapability$1 = { f }; const promiseResolve = function (C, x) { if (anObject(C), isObject(x) && x.constructor === C) return x; const promiseCapability = newPromiseCapability$1.f(C); return (0, promiseCapability.resolve)(x), promiseCapability.promise; }; const hostReportErrors = function (a, b) { const { console } = global_1; console && console.error && (arguments.length === 1 ? console.error(a) : console.error(a, b)); }; const perform = function (exec) { try { return { error: !1, value: exec() }; } catch (error) { return { error: !0, value: error }; } }; const engineIsBrowser = typeof window === 'object'; const task = task$1.set; const SPECIES = wellKnownSymbol('species'); const PROMISE = 'Promise'; const getInternalState$1 = internalState.get; const setInternalState$1 = internalState.set; const getInternalPromiseState = internalState.getterFor(PROMISE); const NativePromisePrototype = nativePromiseConstructor && nativePromiseConstructor.prototype; let PromiseConstructor = nativePromiseConstructor; let PromiseConstructorPrototype = NativePromisePrototype; const TypeError$1 = global_1.TypeError; const document$1 = global_1.document; const { process } = global_1; let newPromiseCapability = newPromiseCapability$1.f; const newGenericPromiseCapability = newPromiseCapability; const DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global_1.dispatchEvent); const NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent === 'function'; const UNHANDLED_REJECTION = 'unhandledrejection'; const REJECTION_HANDLED = 'rejectionhandled'; const PENDING = 0; const FULFILLED = 1; const REJECTED = 2; const HANDLED = 1; const UNHANDLED = 2; let SUBCLASSING = !1; let Internal; let OwnPromiseCapability; let PromiseWrapper; let nativeThen; const FORCED = isForced_1(PROMISE, (() => { const PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor); const GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor); if (!GLOBAL_CORE_JS_PROMISE && engineV8Version === 66) return !0; if (engineV8Version >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return !1; const promise = new PromiseConstructor(((resolve) => { resolve(1); })); const FakePromise = function (exec) { exec((() => {}), (() => {})); }; return (promise.constructor = {})[SPECIES] = FakePromise, !(SUBCLASSING = promise.then((() => {})) instanceof FakePromise) || !GLOBAL_CORE_JS_PROMISE && engineIsBrowser && !NATIVE_REJECTION_EVENT; })); const INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(((iterable) => { PromiseConstructor.all(iterable).catch((() => {})); })); const isThenable = function (it) { let then; return !(!isObject(it) || typeof (then = it.then) !== 'function') && then; }; const notify = function (state, isReject) { if (!state.notified) { state.notified = !0; const chain = state.reactions; microtask((() => { for (let { value } = state, ok = state.state == FULFILLED, index = 0; chain.length > index;) { var result; var then; var exited; const reaction = chain[index++]; const handler = ok ? reaction.ok : reaction.fail; const { resolve } = reaction; const { reject } = reaction; const { domain } = reaction; try { handler ? (ok || (state.rejection === UNHANDLED && onHandleUnhandled(state), state.rejection = HANDLED), !0 === handler ? result = value : (domain && domain.enter(), result = handler(value), domain && (domain.exit(), exited = !0)), result === reaction.promise ? reject(TypeError$1('Promise-chain cycle')) : (then = isThenable(result)) ? then.call(result, resolve, reject) : resolve(result)) : reject(value); } catch (error) { domain && !exited && domain.exit(), reject(error); } }state.reactions = [], state.notified = !1, isReject && !state.rejection && onUnhandled(state); })); } }; const dispatchEvent = function (name, promise, reason) { let event; let handler; DISPATCH_EVENT ? ((event = document$1.createEvent('Event')).promise = promise, event.reason = reason, event.initEvent(name, !1, !0), global_1.dispatchEvent(event)) : event = { promise, reason }, !NATIVE_REJECTION_EVENT && (handler = global_1[`on${name}`]) ? handler(event) : name === UNHANDLED_REJECTION && hostReportErrors('Unhandled promise rejection', reason); }; var onUnhandled = function (state) { task.call(global_1, (() => { let result; const promise = state.facade; const { value } = state; if (isUnhandled(state) && (result = perform((() => { engineIsNode ? process.emit('unhandledRejection', value, promise) : dispatchEvent(UNHANDLED_REJECTION, promise, value); })), state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED, result.error)) throw result.value; })); }; var isUnhandled = function (state) { return state.rejection !== HANDLED && !state.parent; }; var onHandleUnhandled = function (state) { task.call(global_1, (() => { const promise = state.facade; engineIsNode ? process.emit('rejectionHandled', promise) : dispatchEvent(REJECTION_HANDLED, promise, state.value); })); }; const bind = function (fn, state, unwrap) { return function (value) { fn(state, value, unwrap); }; }; const internalReject = function (state, value, unwrap) { state.done || (state.done = !0, unwrap && (state = unwrap), state.value = value, state.state = REJECTED, notify(state, !0)); }; var internalResolve = function (state, value, unwrap) { if (!state.done) { state.done = !0, unwrap && (state = unwrap); try { if (state.facade === value) throw TypeError$1("Promise can't be resolved itself"); const then = isThenable(value); then ? microtask((() => { const wrapper = { done: !1 }; try { then.call(value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state)); } catch (error) { internalReject(wrapper, error, state); } })) : (state.value = value, state.state = FULFILLED, notify(state, !1)); } catch (error) { internalReject({ done: !1 }, error, state); } } }; if (FORCED && (PromiseConstructor = function (executor) { anInstance(this, PromiseConstructor, PROMISE), aFunction(executor), Internal.call(this); const state = getInternalState$1(this); try { executor(bind(internalResolve, state), bind(internalReject, state)); } catch (error) { internalReject(state, error); } }, PromiseConstructorPrototype = PromiseConstructor.prototype, Internal = function (executor) {
    setInternalState$1(this, {
      type: PROMISE, done: !1, notified: !1, parent: !1, reactions: [], rejection: !1, state: PENDING, value: void 0,
    });
  }, Internal.prototype = redefineAll(PromiseConstructorPrototype, { then(onFulfilled, onRejected) { const state = getInternalPromiseState(this); const reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor)); return reaction.ok = typeof onFulfilled !== 'function' || onFulfilled, reaction.fail = typeof onRejected === 'function' && onRejected, reaction.domain = engineIsNode ? process.domain : void 0, state.parent = !0, state.reactions.push(reaction), state.state != PENDING && notify(state, !1), reaction.promise; }, catch(onRejected) { return this.then(void 0, onRejected); } }), OwnPromiseCapability = function () {
    const promise = new Internal(); const
      state = getInternalState$1(promise); this.promise = promise, this.resolve = bind(internalResolve, state), this.reject = bind(internalReject, state);
  }, newPromiseCapability$1.f = newPromiseCapability = function (C) { return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C); }, typeof nativePromiseConstructor === 'function' && NativePromisePrototype !== Object.prototype)) { nativeThen = NativePromisePrototype.then, SUBCLASSING || (redefine(NativePromisePrototype, 'then', (function (onFulfilled, onRejected) { const that = this; return new PromiseConstructor(((resolve, reject) => { nativeThen.call(that, resolve, reject); })).then(onFulfilled, onRejected); }), { unsafe: !0 }), redefine(NativePromisePrototype, 'catch', PromiseConstructorPrototype.catch, { unsafe: !0 })); try { delete NativePromisePrototype.constructor; } catch (error) {}objectSetPrototypeOf && objectSetPrototypeOf(NativePromisePrototype, PromiseConstructorPrototype); }_export({ global: !0, wrap: !0, forced: FORCED }, { Promise: PromiseConstructor }), setToStringTag(PromiseConstructor, PROMISE, !1), setSpecies(PROMISE), PromiseWrapper = getBuiltIn(PROMISE), _export({ target: PROMISE, stat: !0, forced: FORCED }, { reject(r) { const capability = newPromiseCapability(this); return capability.reject.call(void 0, r), capability.promise; } }), _export({ target: PROMISE, stat: !0, forced: FORCED }, { resolve(x) { return promiseResolve(this, x); } }), _export({ target: PROMISE, stat: !0, forced: INCORRECT_ITERATION }, { all(iterable) { const C = this; const capability = newPromiseCapability(C); const { resolve } = capability; const { reject } = capability; const result = perform((() => { const $promiseResolve = aFunction(C.resolve); const values = []; let counter = 0; let remaining = 1; iterate(iterable, ((promise) => { const index = counter++; let alreadyCalled = !1; values.push(void 0), remaining++, $promiseResolve.call(C, promise).then(((value) => { alreadyCalled || (alreadyCalled = !0, values[index] = value, --remaining || resolve(values)); }), reject); })), --remaining || resolve(values); })); return result.error && reject(result.value), capability.promise; }, race(iterable) { const C = this; const capability = newPromiseCapability(C); const { reject } = capability; const result = perform((() => { const $promiseResolve = aFunction(C.resolve); iterate(iterable, ((promise) => { $promiseResolve.call(C, promise).then(capability.resolve, reject); })); })); return result.error && reject(result.value), capability.promise; } }), _export({ target: 'Promise', stat: !0 }, { allSettled(iterable) { const C = this; const capability = newPromiseCapability$1.f(C); const { resolve } = capability; const { reject } = capability; const result = perform((() => { const promiseResolve = aFunction(C.resolve); const values = []; let counter = 0; let remaining = 1; iterate(iterable, ((promise) => { const index = counter++; let alreadyCalled = !1; values.push(void 0), remaining++, promiseResolve.call(C, promise).then(((value) => { alreadyCalled || (alreadyCalled = !0, values[index] = { status: 'fulfilled', value }, --remaining || resolve(values)); }), ((error) => { alreadyCalled || (alreadyCalled = !0, values[index] = { status: 'rejected', reason: error }, --remaining || resolve(values)); })); })), --remaining || resolve(values); })); return result.error && reject(result.value), capability.promise; } }); const PROMISE_ANY_ERROR = 'No one promise resolved'; _export({ target: 'Promise', stat: !0 }, { any(iterable) { const C = this; const capability = newPromiseCapability$1.f(C); const { resolve } = capability; const { reject } = capability; const result = perform((() => { const promiseResolve = aFunction(C.resolve); const errors = []; let counter = 0; let remaining = 1; let alreadyResolved = !1; iterate(iterable, ((promise) => { const index = counter++; let alreadyRejected = !1; errors.push(void 0), remaining++, promiseResolve.call(C, promise).then(((value) => { alreadyRejected || alreadyResolved || (alreadyResolved = !0, resolve(value)); }), ((error) => { alreadyRejected || alreadyResolved || (alreadyRejected = !0, errors[index] = error, --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR))); })); })), --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR)); })); return result.error && reject(result.value), capability.promise; } }); const NON_GENERIC = !!nativePromiseConstructor && fails((() => { nativePromiseConstructor.prototype.finally.call({ then() {} }, (() => {})); })); if (_export({
    target: 'Promise', proto: !0, real: !0, forced: NON_GENERIC,
  }, { finally(onFinally) { const C = speciesConstructor(this, getBuiltIn('Promise')); const isFunction = typeof onFinally === 'function'; return this.then(isFunction ? (x) => promiseResolve(C, onFinally()).then((() => x)) : onFinally, isFunction ? (e) => promiseResolve(C, onFinally()).then((() => { throw e; })) : onFinally); } }), typeof nativePromiseConstructor === 'function') { const method = getBuiltIn('Promise').prototype.finally; nativePromiseConstructor.prototype.finally !== method && redefine(nativePromiseConstructor.prototype, 'finally', method, { unsafe: !0 }); } const domIterables = {
    CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0,
  }; const ARRAY_ITERATOR = 'Array Iterator'; const setInternalState = internalState.set; const getInternalState = internalState.getterFor(ARRAY_ITERATOR); const es_array_iterator = defineIterator(Array, 'Array', (function (iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR, target: toIndexedObject(iterated), index: 0, kind,
    });
  }), (function () { const state = getInternalState(this); const { target } = state; const { kind } = state; const index = state.index++; return !target || index >= target.length ? (state.target = void 0, { value: void 0, done: !0 }) : kind == 'keys' ? { value: index, done: !1 } : kind == 'values' ? { value: target[index], done: !1 } : { value: [index, target[index]], done: !1 }; }), 'values'); iterators.Arguments = iterators.Array, addToUnscopables('keys'), addToUnscopables('values'), addToUnscopables('entries'); const ITERATOR = wellKnownSymbol('iterator'); const TO_STRING_TAG = wellKnownSymbol('toStringTag'); const ArrayValues = es_array_iterator.values; for (const COLLECTION_NAME in domIterables) { const Collection = global_1[COLLECTION_NAME]; const CollectionPrototype = Collection && Collection.prototype; if (CollectionPrototype) { if (CollectionPrototype[ITERATOR] !== ArrayValues) try { createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues); } catch (error) { CollectionPrototype[ITERATOR] = ArrayValues; } if (CollectionPrototype[TO_STRING_TAG] || createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME), domIterables[COLLECTION_NAME]) for (const METHOD_NAME in es_array_iterator) if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try { createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]); } catch (error) { CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME]; } } }path.Promise, _export({ target: 'Promise', stat: !0 }, { try(callbackfn) { const promiseCapability = newPromiseCapability$1.f(this); const result = perform(callbackfn); return (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value), promiseCapability.promise; } }); const MATCH$1 = wellKnownSymbol('match'); const isRegexp = function (it) { let isRegExp; return isObject(it) && (void 0 !== (isRegExp = it[MATCH$1]) ? !!isRegExp : classofRaw(it) == 'RegExp'); }; const notARegexp = function (it) { if (isRegexp(it)) throw TypeError("The method doesn't accept regular expressions"); return it; }; const MATCH = wellKnownSymbol('match'); const correctIsRegexpLogic = function (METHOD_NAME) { const regexp = /./; try { '/./'[METHOD_NAME](regexp); } catch (error1) { try { return regexp[MATCH] = !1, '/./'[METHOD_NAME](regexp); } catch (error2) {} } return !1; }; const getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f; const $startsWith = ''.startsWith; const { min } = Math; const CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith'); const MDN_POLYFILL_BUG = !(CORRECT_IS_REGEXP_LOGIC || (descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith'), !descriptor || descriptor.writable)); let descriptor; _export({ target: 'String', proto: !0, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, { startsWith(searchString) { const that = String(requireObjectCoercible(this)); notARegexp(searchString); const index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length)); const search = String(searchString); return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search; } }), entryUnbind('String', 'startsWith'); var global$1 = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || void 0 !== global$1 && global$1; const support = {
    searchParams: 'URLSearchParams' in global$1, iterable: 'Symbol' in global$1 && 'iterator' in Symbol, blob: 'FileReader' in global$1 && 'Blob' in global$1 && (function () { try { return new Blob(), !0; } catch (e) { return !1; } }()), formData: 'FormData' in global$1, arrayBuffer: 'ArrayBuffer' in global$1,
  }; function isDataView(obj) { return obj && DataView.prototype.isPrototypeOf(obj); } if (support.arrayBuffer) {
    const viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];
    var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1; };
  } function normalizeName(name) { if (typeof name !== 'string' && (name = String(name)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') throw new TypeError(`Invalid character in header field name: "${name}"`); return name.toLowerCase(); } function normalizeValue(value) { return typeof value !== 'string' && (value = String(value)), value; } function iteratorFor(items) { const iterator = { next() { const value = items.shift(); return { done: void 0 === value, value }; } }; return support.iterable && (iterator[Symbol.iterator] = function () { return iterator; }), iterator; } function Headers(headers) { this.map = {}, headers instanceof Headers ? headers.forEach((function (value, name) { this.append(name, value); }), this) : Array.isArray(headers) ? headers.forEach((function (header) { this.append(header[0], header[1]); }), this) : headers && Object.getOwnPropertyNames(headers).forEach((function (name) { this.append(name, headers[name]); }), this); } function consumed(body) { if (body.bodyUsed) return Promise.reject(new TypeError('Already read')); body.bodyUsed = !0; } function fileReaderReady(reader) { return new Promise(((resolve, reject) => { reader.onload = function () { resolve(reader.result); }, reader.onerror = function () { reject(reader.error); }; })); } function readBlobAsArrayBuffer(blob) {
    const reader = new FileReader(); const
      promise = fileReaderReady(reader); return reader.readAsArrayBuffer(blob), promise;
  } function readBlobAsText(blob) {
    const reader = new FileReader(); const
      promise = fileReaderReady(reader); return reader.readAsText(blob), promise;
  } function readArrayBufferAsText(buf) { for (var view = new Uint8Array(buf), chars = new Array(view.length), i = 0; i < view.length; i++)chars[i] = String.fromCharCode(view[i]); return chars.join(''); } function bufferClone(buf) { if (buf.slice) return buf.slice(0); const view = new Uint8Array(buf.byteLength); return view.set(new Uint8Array(buf)), view.buffer; } function Body() { return this.bodyUsed = !1, this._initBody = function (body) { this.bodyUsed = this.bodyUsed, this._bodyInit = body, body ? typeof body === 'string' ? this._bodyText = body : support.blob && Blob.prototype.isPrototypeOf(body) ? this._bodyBlob = body : support.formData && FormData.prototype.isPrototypeOf(body) ? this._bodyFormData = body : support.searchParams && URLSearchParams.prototype.isPrototypeOf(body) ? this._bodyText = body.toString() : support.arrayBuffer && support.blob && isDataView(body) ? (this._bodyArrayBuffer = bufferClone(body.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body)) ? this._bodyArrayBuffer = bufferClone(body) : this._bodyText = body = Object.prototype.toString.call(body) : this._bodyText = '', this.headers.get('content-type') || (typeof body === 'string' ? this.headers.set('content-type', 'text/plain;charset=UTF-8') : this._bodyBlob && this._bodyBlob.type ? this.headers.set('content-type', this._bodyBlob.type) : support.searchParams && URLSearchParams.prototype.isPrototypeOf(body) && this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')); }, support.blob && (this.blob = function () { const rejected = consumed(this); if (rejected) return rejected; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (this._bodyFormData) throw new Error('could not read FormData body as blob'); return Promise.resolve(new Blob([this._bodyText])); }, this.arrayBuffer = function () { if (this._bodyArrayBuffer) { const isConsumed = consumed(this); return isConsumed || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer)); } return this.blob().then(readBlobAsArrayBuffer); }), this.text = function () { const rejected = consumed(this); if (rejected) return rejected; if (this._bodyBlob) return readBlobAsText(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer)); if (this._bodyFormData) throw new Error('could not read FormData body as text'); return Promise.resolve(this._bodyText); }, support.formData && (this.formData = function () { return this.text().then(decode); }), this.json = function () { return this.text().then(JSON.parse); }, this; }Headers.prototype.append = function (name, value) { name = normalizeName(name), value = normalizeValue(value); const oldValue = this.map[name]; this.map[name] = oldValue ? `${oldValue}, ${value}` : value; }, Headers.prototype.delete = function (name) { delete this.map[normalizeName(name)]; }, Headers.prototype.get = function (name) { return name = normalizeName(name), this.has(name) ? this.map[name] : null; }, Headers.prototype.has = function (name) { return this.map.hasOwnProperty(normalizeName(name)); }, Headers.prototype.set = function (name, value) { this.map[normalizeName(name)] = normalizeValue(value); }, Headers.prototype.forEach = function (callback, thisArg) { for (const name in this.map) this.map.hasOwnProperty(name) && callback.call(thisArg, this.map[name], name, this); }, Headers.prototype.keys = function () { const items = []; return this.forEach(((value, name) => { items.push(name); })), iteratorFor(items); }, Headers.prototype.values = function () { const items = []; return this.forEach(((value) => { items.push(value); })), iteratorFor(items); }, Headers.prototype.entries = function () { const items = []; return this.forEach(((value, name) => { items.push([name, value]); })), iteratorFor(items); }, support.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries); const methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']; function normalizeMethod(method) { const upcased = method.toUpperCase(); return methods.indexOf(upcased) > -1 ? upcased : method; } function Request(input, options) { if (!(this instanceof Request)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.'); let { body } = options = options || {}; if (input instanceof Request) { if (input.bodyUsed) throw new TypeError('Already read'); this.url = input.url, this.credentials = input.credentials, options.headers || (this.headers = new Headers(input.headers)), this.method = input.method, this.mode = input.mode, this.signal = input.signal, body || input._bodyInit == null || (body = input._bodyInit, input.bodyUsed = !0); } else this.url = String(input); if (this.credentials = options.credentials || this.credentials || 'same-origin', !options.headers && this.headers || (this.headers = new Headers(options.headers)), this.method = normalizeMethod(options.method || this.method || 'GET'), this.mode = options.mode || this.mode || null, this.signal = options.signal || this.signal, this.referrer = null, (this.method === 'GET' || this.method === 'HEAD') && body) throw new TypeError('Body not allowed for GET or HEAD requests'); if (this._initBody(body), !(this.method !== 'GET' && this.method !== 'HEAD' || options.cache !== 'no-store' && options.cache !== 'no-cache')) { const reParamSearch = /([?&])_=[^&]*/; if (reParamSearch.test(this.url)) this.url = this.url.replace(reParamSearch, `$1_=${(new Date()).getTime()}`); else { this.url += `${/\?/.test(this.url) ? '&' : '?'}_=${(new Date()).getTime()}`; } } } function decode(body) { const form = new FormData(); return body.trim().split('&').forEach(((bytes) => { if (bytes) { const split = bytes.split('='); const name = split.shift().replace(/\+/g, ' '); const value = split.join('=').replace(/\+/g, ' '); form.append(decodeURIComponent(name), decodeURIComponent(value)); } })), form; } function parseHeaders(rawHeaders) { const headers = new Headers(); return rawHeaders.replace(/\r?\n[\t ]+/g, ' ').split('\r').map(((header) => (header.indexOf('\n') === 0 ? header.substr(1, header.length) : header))).forEach(((line) => { const parts = line.split(':'); const key = parts.shift().trim(); if (key) { const value = parts.join(':').trim(); headers.append(key, value); } })), headers; } function Response(bodyInit, options) { if (!(this instanceof Response)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.'); options || (options = {}), this.type = 'default', this.status = void 0 === options.status ? 200 : options.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = void 0 === options.statusText ? '' : `${options.statusText}`, this.headers = new Headers(options.headers), this.url = options.url || '', this._initBody(bodyInit); }Request.prototype.clone = function () { return new Request(this, { body: this._bodyInit }); }, Body.call(Request.prototype), Body.call(Response.prototype), Response.prototype.clone = function () {
    return new Response(this._bodyInit, {
      status: this.status, statusText: this.statusText, headers: new Headers(this.headers), url: this.url,
    });
  }, Response.error = function () { const response = new Response(null, { status: 0, statusText: '' }); return response.type = 'error', response; }; const redirectStatuses = [301, 302, 303, 307, 308]; Response.redirect = function (url, status) { if (redirectStatuses.indexOf(status) === -1) throw new RangeError('Invalid status code'); return new Response(null, { status, headers: { location: url } }); }; let { DOMException } = global$1; try { new DOMException(); } catch (err) { DOMException = function (message, name) { this.message = message, this.name = name; const error = Error(message); this.stack = error.stack; }, DOMException.prototype = Object.create(Error.prototype), DOMException.prototype.constructor = DOMException; } function fetch$1(input, init) { return new Promise(((resolve, reject) => { const request = new Request(input, init); if (request.signal && request.signal.aborted) return reject(new DOMException('Aborted', 'AbortError')); const xhr = new XMLHttpRequest(); function abortXhr() { xhr.abort(); }xhr.onload = function () { const options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') }; options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL'); const body = 'response' in xhr ? xhr.response : xhr.responseText; setTimeout((() => { resolve(new Response(body, options)); }), 0); }, xhr.onerror = function () { setTimeout((() => { reject(new TypeError('Network request failed')); }), 0); }, xhr.ontimeout = function () { setTimeout((() => { reject(new TypeError('Network request failed')); }), 0); }, xhr.onabort = function () { setTimeout((() => { reject(new DOMException('Aborted', 'AbortError')); }), 0); }, xhr.open(request.method, (function (url) { try { return url === '' && global$1.location.href ? global$1.location.href : url; } catch (e) { return url; } }(request.url)), !0), request.credentials === 'include' ? xhr.withCredentials = !0 : request.credentials === 'omit' && (xhr.withCredentials = !1), 'responseType' in xhr && (support.blob ? xhr.responseType = 'blob' : support.arrayBuffer && request.headers.get('Content-Type') && request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1 && (xhr.responseType = 'arraybuffer')), !init || typeof init.headers !== 'object' || init.headers instanceof Headers ? request.headers.forEach(((value, name) => { xhr.setRequestHeader(name, value); })) : Object.getOwnPropertyNames(init.headers).forEach(((name) => { xhr.setRequestHeader(name, normalizeValue(init.headers[name])); })), request.signal && (request.signal.addEventListener('abort', abortXhr), xhr.onreadystatechange = function () { xhr.readyState === 4 && request.signal.removeEventListener('abort', abortXhr); }), xhr.send(void 0 === request._bodyInit ? null : request._bodyInit); })); }fetch$1.polyfill = !0, global$1.fetch || (global$1.fetch = fetch$1, global$1.Headers = Headers, global$1.Request = Request, global$1.Response = Response), Element.prototype.getAttributeNames == null && (Element.prototype.getAttributeNames = function () { for (var { attributes } = this, { length } = attributes, result = new Array(length), i = 0; i < length; i++)result[i] = attributes[i].name; return result; }), Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) { for (var matches = (this.document || this.ownerDocument).querySelectorAll(s), i = matches.length; --i >= 0 && matches.item(i) !== this;);return i > -1; }), Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (s) { let el = this; do { if (el.matches(s)) return el; el = el.parentElement || el.parentNode; } while (el !== null && el.nodeType === 1); return null; }); const Connection = (function () {
    function Connection() { _classCallCheck(this, Connection), this.headers = {}; } return _createClass(Connection, [{ key: 'onMessage', value(message, payload) { message.component.receiveMessage(message, payload); } }, { key: 'onError', value(message, status, response) { return message.component.messageSendFailed(), store$2.onErrorCallback(status, response); } }, { key: 'showExpiredMessage', value(response, message) { store$2.sessionHasExpiredCallback ? store$2.sessionHasExpiredCallback(response, message) : confirm('This page has expired.\nWould you like to refresh the page?') && window.location.reload(); } }, {
      key: 'sendMessage',
      value(message) {
        const _this = this; const payload = message.payload(); const csrfToken = getCsrfToken(); const socketId = this.getSocketId(); if (window.__testing_request_interceptor) return window.__testing_request_interceptor(payload, this); fetch(''.concat(window.livewire_app_url, '/livewire/message/').concat(payload.fingerprint.name), {
          method: 'POST', body: JSON.stringify(payload), credentials: 'same-origin', headers: _objectSpread2(_objectSpread2(_objectSpread2({ 'Content-Type': 'application/json', Accept: 'text/html, application/xhtml+xml', 'X-Livewire': !0 }, this.headers), {}, { Referer: window.location.href }, csrfToken && { 'X-CSRF-TOKEN': csrfToken }), socketId && { 'X-Socket-ID': socketId }),
        }).then(((response) => { if (response.ok)response.text().then(((response) => { _this.isOutputFromDump(response) ? (_this.onError(message), _this.showHtmlModal(response)) : _this.onMessage(message, JSON.parse(response)); })); else { if (!1 === _this.onError(message, response.status, response)) return; if (response.status === 419) { if (store$2.sessionHasExpired) return; store$2.sessionHasExpired = !0, _this.showExpiredMessage(response, message); } else response.text().then(((response) => { _this.showHtmlModal(response); })); } })).catch((() => { _this.onError(message); }));
      },
    }, { key: 'isOutputFromDump', value(output) { return !!output.match(/<script>Sfdump\(".+"\)<\/script>/); } }, { key: 'getSocketId', value() { if (typeof Echo !== 'undefined') return Echo.socketId(); } }, { key: 'showHtmlModal', value(html) { const _this2 = this; const page = document.createElement('html'); page.innerHTML = html, page.querySelectorAll('a').forEach(((a) => a.setAttribute('target', '_top'))); let modal = document.getElementById('livewire-error'); void 0 !== modal && modal != null ? modal.innerHTML = '' : ((modal = document.createElement('div')).id = 'livewire-error', modal.style.position = 'fixed', modal.style.width = '100vw', modal.style.height = '100vh', modal.style.padding = '50px', modal.style.backgroundColor = 'rgba(0, 0, 0, .6)', modal.style.zIndex = 2e5); const iframe = document.createElement('iframe'); iframe.style.backgroundColor = '#17161A', iframe.style.borderRadius = '5px', iframe.style.width = '100%', iframe.style.height = '100%', modal.appendChild(iframe), document.body.prepend(modal), document.body.style.overflow = 'hidden', iframe.contentWindow.document.open(), iframe.contentWindow.document.write(page.outerHTML), iframe.contentWindow.document.close(), modal.addEventListener('click', (() => _this2.hideHtmlModal(modal))), modal.setAttribute('tabindex', 0), modal.addEventListener('keydown', ((e) => { e.key === 'Escape' && _this2.hideHtmlModal(modal); })), modal.focus(); } }, { key: 'hideHtmlModal', value(modal) { modal.outerHTML = '', document.body.style.overflow = 'visible'; } }]), Connection;
  }()); const _default$4 = (function (_Action) { _inherits(_default, _Action); const _super = _createSuper(_default); function _default(method, params, el) { let _this; const skipWatcher = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; return _classCallCheck(this, _default), (_this = _super.call(this, el, skipWatcher)).type = 'callMethod', _this.method = method, _this.payload = { id: _this.signature, method, params }, _this; } return _default; }(_default$6)); function Polling() { store$2.registerHook('element.initialized', ((el, component) => { if (!wireDirectives(el).missing('poll')) { const intervalId = fireActionOnInterval(el, component); component.addListenerForTeardown((() => { clearInterval(intervalId); })), el.__livewire_polling_interval = intervalId; } })), store$2.registerHook('element.updating', ((from, to, component) => { void 0 === from.__livewire_polling_interval && wireDirectives(from).missing('poll') && wireDirectives(to).has('poll') && setTimeout((() => { const intervalId = fireActionOnInterval(from, component); component.addListenerForTeardown((() => { clearInterval(intervalId); })), from.__livewire_polling_interval = intervalId; }), 0); })); } function fireActionOnInterval(node, component) { const interval = wireDirectives(node).get('poll').durationOr(2e3); return setInterval((() => { if (!1 !== node.isConnected) { const directives = wireDirectives(node); if (!directives.missing('poll')) { const directive = directives.get('poll'); const method = directive.method || '$refresh'; store$2.livewireIsInBackground && !directive.modifiers.includes('keep-alive') && Math.random() < 0.95 || directive.modifiers.includes('visible') && !inViewport(directive.el) || store$2.livewireIsOffline || component.addAction(new _default$4(method, directive.params, node)); } } }), interval); } function inViewport(el) { const bounding = el.getBoundingClientRect(); return bounding.top < (window.innerHeight || document.documentElement.clientHeight) && bounding.left < (window.innerWidth || document.documentElement.clientWidth) && bounding.bottom > 0 && bounding.right > 0; } const _default$3 = (function () { function _default(component, updateQueue) { _classCallCheck(this, _default), this.component = component, this.updateQueue = updateQueue; } return _createClass(_default, [{ key: 'payload', value() { return { fingerprint: this.component.fingerprint, serverMemo: this.component.serverMemo, updates: this.updateQueue.map(((update) => ({ type: update.type, payload: update.payload }))) }; } }, { key: 'shouldSkipWatcherForDataKey', value(dataKey) { if (this.response.effects.dirty.includes(dataKey)) return !1; return this.updateQueue.filter(((update) => { return subject = update.name, value = dataKey, typeof subject === 'string' && typeof value === 'string' && subject.split('.')[0] === value.split('.')[0]; let subject; let value; })).some(((update) => update.skipWatcher)); } }, { key: 'storeResponse', value(payload) { return this.response = payload; } }, { key: 'resolve', value() { const returns = this.response.effects.returns || []; this.updateQueue.forEach(((update) => { update.type === 'callMethod' && update.resolve(void 0 !== returns[update.signature] ? returns[update.signature] : void 0 !== returns[update.method] ? returns[update.method] : null); })); } }, { key: 'reject', value() { this.updateQueue.forEach(((update) => { update.reject(); })); } }]), _default; }()); const _default$2 = (function (_Message) { _inherits(_default, _Message); const _super = _createSuper(_default); function _default(component, action) { return _classCallCheck(this, _default), _super.call(this, component, [action]); } return _createClass(_default, [{ key: 'prefetchId', get() { return this.updateQueue[0].toId(); } }]), _default; }(_default$3)); function morphAttrs(fromNode, toNode) { if ((void 0 === fromNode._x_isShown || void 0 === toNode._x_isShown) && (!fromNode._x_isShown || toNode._x_isShown) && (fromNode._x_isShown || !toNode._x_isShown)) { let i; let attr; let attrName; let attrNamespaceURI; let attrValue; let attrs = toNode.attributes; for (i = attrs.length - 1; i >= 0; --i)attrName = (attr = attrs[i]).name, attrNamespaceURI = attr.namespaceURI, attrValue = attr.value, attrNamespaceURI ? (attrName = attr.localName || attrName, fromNode.getAttributeNS(attrNamespaceURI, attrName) !== attrValue && (attr.prefix === 'xmlns' && (attrName = attr.name), fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue))) : fromNode.getAttribute(attrName) !== attrValue && fromNode.setAttribute(attrName, attrValue); for (i = (attrs = fromNode.attributes).length - 1; i >= 0; --i)!1 !== (attr = attrs[i]).specified && (attrName = attr.name, (attrNamespaceURI = attr.namespaceURI) ? (attrName = attr.localName || attrName, toNode.hasAttributeNS(attrNamespaceURI, attrName) || fromNode.removeAttributeNS(attrNamespaceURI, attrName)) : toNode.hasAttribute(attrName) || fromNode.removeAttribute(attrName)); } } function syncBooleanAttrProp(fromEl, toEl, name) { fromEl[name] !== toEl[name] && (fromEl[name] = toEl[name], fromEl[name] ? fromEl.setAttribute(name, '') : fromEl.removeAttribute(name)); } const specialElHandlers = {
    OPTION(fromEl, toEl) { let { parentNode } = fromEl; if (parentNode) { let parentName = parentNode.nodeName.toUpperCase(); parentName === 'OPTGROUP' && (parentName = (parentNode = parentNode.parentNode) && parentNode.nodeName.toUpperCase()), parentName !== 'SELECT' || parentNode.hasAttribute('multiple') || (fromEl.hasAttribute('selected') && !toEl.selected && (fromEl.setAttribute('selected', 'selected'), fromEl.removeAttribute('selected')), parentNode.selectedIndex = -1); }syncBooleanAttrProp(fromEl, toEl, 'selected'); }, INPUT(fromEl, toEl) { syncBooleanAttrProp(fromEl, toEl, 'checked'), syncBooleanAttrProp(fromEl, toEl, 'disabled'), fromEl.value !== toEl.value && (fromEl.value = toEl.value), toEl.hasAttribute('value') || fromEl.removeAttribute('value'); }, TEXTAREA(fromEl, toEl) { const newValue = toEl.value; fromEl.value !== newValue && (fromEl.value = newValue); const { firstChild } = fromEl; if (firstChild) { const oldValue = firstChild.nodeValue; if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) return; firstChild.nodeValue = newValue; } }, SELECT(fromEl, toEl) { if (!toEl.hasAttribute('multiple')) { for (var optgroup, nodeName, selectedIndex = -1, i = 0, curChild = fromEl.firstChild; curChild;) if ((nodeName = curChild.nodeName && curChild.nodeName.toUpperCase()) === 'OPTGROUP')curChild = (optgroup = curChild).firstChild; else { if (nodeName === 'OPTION') { if (curChild.hasAttribute('selected')) { selectedIndex = i; break; }i++; }!(curChild = curChild.nextSibling) && optgroup && (curChild = optgroup.nextSibling, optgroup = null); }fromEl.selectedIndex = selectedIndex; } },
  }; let range; const NS_XHTML = 'http://www.w3.org/1999/xhtml'; const doc = typeof document === 'undefined' ? void 0 : document; const HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template'); const HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange(); function createFragmentFromTemplate(str) { const template = doc.createElement('template'); return template.innerHTML = str, template.content.childNodes[0]; } function createFragmentFromRange(str) { return range || (range = doc.createRange()).selectNode(doc.body), range.createContextualFragment(str).childNodes[0]; } function createFragmentFromWrap(str) { const fragment = doc.createElement('body'); return fragment.innerHTML = str, fragment.childNodes[0]; } function toElement(str) { return str = str.trim(), HAS_TEMPLATE_SUPPORT ? createFragmentFromTemplate(str) : HAS_RANGE_SUPPORT ? createFragmentFromRange(str) : createFragmentFromWrap(str); } function compareNodeNames(fromEl, toEl) { const fromNodeName = fromEl.nodeName; const toNodeName = toEl.nodeName; return fromNodeName === toNodeName || !!(toEl.actualize && fromNodeName.charCodeAt(0) < 91 && toNodeName.charCodeAt(0) > 90) && fromNodeName === toNodeName.toUpperCase(); } function createElementNS(name, namespaceURI) { return namespaceURI && namespaceURI !== NS_XHTML ? doc.createElementNS(namespaceURI, name) : doc.createElement(name); } function moveChildren(fromEl, toEl) { for (let curChild = fromEl.firstChild; curChild;) { const nextChild = curChild.nextSibling; toEl.appendChild(curChild), curChild = nextChild; } return toEl; } const ELEMENT_NODE = 1; const DOCUMENT_FRAGMENT_NODE = 11; const TEXT_NODE = 3; const COMMENT_NODE = 8; function noop() {} function defaultGetNodeKey(node) { return node.id; } function callHook(hook) { hook.name !== 'getNodeKey' && hook.name; for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)params[_key - 1] = arguments[_key]; if (typeof params[0].hasAttribute === 'function') return hook.apply(void 0, params); } function morphdomFactory(morphAttrs) {
    return function (fromNode, toNode, options) {
      if (options || (options = {}), typeof toNode === 'string') if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') { const toNodeHtml = toNode; (toNode = doc.createElement('html')).innerHTML = toNodeHtml; } else toNode = toElement(toNode); const getNodeKey = options.getNodeKey || defaultGetNodeKey; const onBeforeNodeAdded = options.onBeforeNodeAdded || noop; const onNodeAdded = options.onNodeAdded || noop; const onBeforeElUpdated = options.onBeforeElUpdated || noop; const onElUpdated = options.onElUpdated || noop; const onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop; const onNodeDiscarded = options.onNodeDiscarded || noop; const onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop; const childrenOnly = !0 === options.childrenOnly; const fromNodesLookup = Object.create(null); const keyedRemovalList = []; function addKeyedRemoval(key) { keyedRemovalList.push(key); } function walkDiscardedChildNodes(node, skipKeyedNodes) { if (node.nodeType === ELEMENT_NODE) for (let curChild = node.firstChild; curChild;) { let key = void 0; skipKeyedNodes && (key = callHook(getNodeKey, curChild)) ? addKeyedRemoval(key) : (callHook(onNodeDiscarded, curChild), curChild.firstChild && walkDiscardedChildNodes(curChild, skipKeyedNodes)), curChild = curChild.nextSibling; } } function removeNode(node, parentNode, skipKeyedNodes) { !1 !== callHook(onBeforeNodeDiscarded, node) && (parentNode && parentNode.removeChild(node), callHook(onNodeDiscarded, node), walkDiscardedChildNodes(node, skipKeyedNodes)); } function handleNodeAdded(el) {
        if (callHook(onNodeAdded, el), !el.skipAddingChildren) {
          for (let curChild = el.firstChild; curChild;) {
            const { nextSibling } = curChild; const
              key = callHook(getNodeKey, curChild); if (key) { const unmatchedFromEl = fromNodesLookup[key]; unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl) ? (curChild.parentNode.replaceChild(unmatchedFromEl, curChild), morphEl(unmatchedFromEl, curChild)) : handleNodeAdded(curChild); } else handleNodeAdded(curChild); curChild = nextSibling;
          }
        }
      } function morphEl(fromEl, toEl, childrenOnly) { const toElKey = callHook(getNodeKey, toEl); if (toElKey && delete fromNodesLookup[toElKey], !childrenOnly) { if (!1 === callHook(onBeforeElUpdated, fromEl, toEl)) return; if (fromEl.skipElUpdatingButStillUpdateChildren || morphAttrs(fromEl, toEl), callHook(onElUpdated, fromEl), !1 === callHook(onBeforeElChildrenUpdated, fromEl, toEl)) return; }fromEl.nodeName !== 'TEXTAREA' ? (function (fromEl, toEl) { let curToNodeKey; let curFromNodeKey; let fromNextSibling; let toNextSibling; let matchingFromEl; let curToNodeChild = toEl.firstChild; let curFromNodeChild = fromEl.firstChild; outer:for (;curToNodeChild;) { for (toNextSibling = curToNodeChild.nextSibling, curToNodeKey = callHook(getNodeKey, curToNodeChild); curFromNodeChild;) { if (fromNextSibling = curFromNodeChild.nextSibling, curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) { curToNodeChild = toNextSibling, curFromNodeChild = fromNextSibling; continue outer; }curFromNodeKey = callHook(getNodeKey, curFromNodeChild); const curFromNodeType = curFromNodeChild.nodeType; let isCompatible = void 0; if (curFromNodeType === curToNodeChild.nodeType && (curFromNodeType === ELEMENT_NODE ? (curToNodeKey ? curToNodeKey !== curFromNodeKey && ((matchingFromEl = fromNodesLookup[curToNodeKey]) ? fromNextSibling === matchingFromEl ? isCompatible = !1 : (fromEl.insertBefore(matchingFromEl, curFromNodeChild), curFromNodeKey ? addKeyedRemoval(curFromNodeKey) : removeNode(curFromNodeChild, fromEl, !0), curFromNodeChild = matchingFromEl) : isCompatible = !1) : curFromNodeKey && (isCompatible = !1), (isCompatible = !1 !== isCompatible && compareNodeNames(curFromNodeChild, curToNodeChild)) && (!curToNodeChild.isEqualNode(curFromNodeChild) && curToNodeChild.nextElementSibling && curToNodeChild.nextElementSibling.isEqualNode(curFromNodeChild) ? isCompatible = !1 : morphEl(curFromNodeChild, curToNodeChild))) : curFromNodeType !== TEXT_NODE && curFromNodeType != COMMENT_NODE || (isCompatible = !0, curFromNodeChild.nodeValue !== curToNodeChild.nodeValue && (curFromNodeChild.nodeValue = curToNodeChild.nodeValue))), isCompatible) { curToNodeChild = toNextSibling, curFromNodeChild = fromNextSibling; continue outer; } if (curToNodeChild.nextElementSibling && curToNodeChild.nextElementSibling.isEqualNode(curFromNodeChild)) { const nodeToBeAdded = curToNodeChild.cloneNode(!0); fromEl.insertBefore(nodeToBeAdded, curFromNodeChild), handleNodeAdded(nodeToBeAdded), curToNodeChild = curToNodeChild.nextElementSibling.nextSibling, curFromNodeChild = fromNextSibling; continue outer; }curFromNodeKey ? addKeyedRemoval(curFromNodeKey) : removeNode(curFromNodeChild, fromEl, !0), curFromNodeChild = fromNextSibling; } if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild))fromEl.appendChild(matchingFromEl), morphEl(matchingFromEl, curToNodeChild); else { const onBeforeNodeAddedResult = callHook(onBeforeNodeAdded, curToNodeChild); !1 !== onBeforeNodeAddedResult && (onBeforeNodeAddedResult && (curToNodeChild = onBeforeNodeAddedResult), curToNodeChild.actualize && (curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc)), fromEl.appendChild(curToNodeChild), handleNodeAdded(curToNodeChild)); }curToNodeChild = toNextSibling, curFromNodeChild = fromNextSibling; }!(function (fromEl, curFromNodeChild, curFromNodeKey) { for (;curFromNodeChild;) { const fromNextSibling = curFromNodeChild.nextSibling; (curFromNodeKey = callHook(getNodeKey, curFromNodeChild)) ? addKeyedRemoval(curFromNodeKey) : removeNode(curFromNodeChild, fromEl, !0), curFromNodeChild = fromNextSibling; } }(fromEl, curFromNodeChild, curFromNodeKey)); const specialElHandler = specialElHandlers[fromEl.nodeName]; specialElHandler && !fromEl.isLivewireModel && specialElHandler(fromEl, toEl); }(fromEl, toEl)) : fromEl.innerHTML != toEl.innerHTML && specialElHandlers.TEXTAREA(fromEl, toEl); }!(function indexTree(node) { if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE) for (let curChild = node.firstChild; curChild;) { const key = callHook(getNodeKey, curChild); key && (fromNodesLookup[key] = curChild), indexTree(curChild), curChild = curChild.nextSibling; } }(fromNode)); let morphedNode = fromNode; const morphedNodeType = morphedNode.nodeType; const toNodeType = toNode.nodeType; if (!childrenOnly) if (morphedNodeType === ELEMENT_NODE)toNodeType === ELEMENT_NODE ? compareNodeNames(fromNode, toNode) || (callHook(onNodeDiscarded, fromNode), morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI))) : morphedNode = toNode; else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { if (toNodeType === morphedNodeType) return morphedNode.nodeValue !== toNode.nodeValue && (morphedNode.nodeValue = toNode.nodeValue), morphedNode; morphedNode = toNode; } if (morphedNode === toNode)callHook(onNodeDiscarded, fromNode); else { if (toNode.isSameNode && toNode.isSameNode(morphedNode)) return; if (morphEl(morphedNode, toNode, childrenOnly), keyedRemovalList) for (let i = 0, len = keyedRemovalList.length; i < len; i++) { const elToRemove = fromNodesLookup[keyedRemovalList[i]]; elToRemove && removeNode(elToRemove, elToRemove.parentNode, !1); } } return !childrenOnly && morphedNode !== fromNode && fromNode.parentNode && (morphedNode.actualize && (morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc)), fromNode.parentNode.replaceChild(morphedNode, fromNode)), morphedNode;
    };
  } const morphdom = morphdomFactory(morphAttrs); const _default$1 = (function (_Action) { _inherits(_default, _Action); const _super = _createSuper(_default); function _default(name, value, el) { let _this; return _classCallCheck(this, _default), (_this = _super.call(this, el)).type = 'syncInput', _this.name = name, _this.payload = { id: _this.signature, name, value }, _this; } return _default; }(_default$6)); const _default = (function (_Action) { _inherits(_default, _Action); const _super = _createSuper(_default); function _default(name, value, el) { let _this; const skipWatcher = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; return _classCallCheck(this, _default), (_this = _super.call(this, el, skipWatcher)).type = 'syncInput', _this.name = name, _this.payload = { id: _this.signature, name, value }, _this; } return _default; }(_default$6)); const nodeInitializer = {
    initialize: function initialize(el, component) { const _this = this; if (store$2.initialRenderIsFinished && el.tagName.toLowerCase() === 'script') return eval(el.innerHTML), !1; wireDirectives(el).all().forEach(((directive) => { switch (directive.type) { case 'init': _this.fireActionRightAway(el, directive, component); break; case 'model': if (!directive.value) { console.warn('Livewire: [wire:model] is missing a value.', el); break; }DOM.setInputValueFromModel(el, component), _this.attachModelListener(el, directive, component); break; default: store$2.directives.has(directive.type) && store$2.directives.call(directive.type, el, directive, component), _this.attachDomListener(el, directive, component); } })), store$2.callHook('element.initialized', el, component); }, fireActionRightAway(el, directive, component) { const method = directive.value ? directive.method : '$refresh'; component.addAction(new _default$4(method, directive.params, el)); }, attachModelListener(el, directive, component) { el.isLivewireModel = !0; const isLazy = directive.modifiers.includes('lazy'); const hasDebounceModifier = directive.modifiers.includes('debounce'); if (store$2.callHook('interceptWireModelAttachListener', directive, el, component), el.tagName.toLowerCase() !== 'input' || el.type !== 'file') { let condition; let callback; let time; const event = el.tagName.toLowerCase() === 'select' || ['checkbox', 'radio'].includes(el.type) || directive.modifiers.includes('lazy') ? 'change' : 'input'; const handler = (condition = hasDebounceModifier || DOM.isTextInput(el) && !isLazy, callback = function (e) { const model = directive.value; const el = e.target; const value = e instanceof CustomEvent && void 0 !== e.detail && void 0 === window.document.documentMode ? e.detail || e.target.value : DOM.valueFromInput(el, component); directive.modifiers.includes('defer') ? component.addAction(new _default(model, value, el)) : component.addAction(new _default$1(model, value, el)); }, time = directive.durationOr(150), condition ? component.modelSyncDebounce(callback, time) : callback); el.addEventListener(event, handler), component.addListenerForTeardown((() => { el.removeEventListener(event, handler); })), /^((?!chrome|android).)*safari/i.test(navigator.userAgent) && el.addEventListener('animationstart', ((e) => { e.animationName === 'livewireautofill' && (e.target.dispatchEvent(new Event('change', { bubbles: !0 })), e.target.dispatchEvent(new Event('input', { bubbles: !0 }))); })); } }, attachDomListener(el, directive, component) { switch (directive.type) { case 'keydown': case 'keyup': this.attachListener(el, directive, component, ((e) => { const selectedSystemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super'].filter(((key) => directive.modifiers.includes(key))); if (selectedSystemKeyModifiers.length > 0 && selectedSystemKeyModifiers.filter(((key) => (key !== 'cmd' && key !== 'super' || (key = 'meta'), !e[''.concat(key, 'Key')]))).length > 0) return !1; if (e.keyCode === 32 || e.key === ' ' || e.key === 'Spacebar') return directive.modifiers.includes('space'); const modifiers = directive.modifiers.filter(((modifier) => !modifier.match(/^debounce$/) && !modifier.match(/^[0-9]+m?s$/))); return Boolean(modifiers.length === 0 || e.key && modifiers.includes(kebabCase(e.key))); })); break; case 'click': this.attachListener(el, directive, component, ((e) => { if (directive.modifiers.includes('self')) return el.isSameNode(e.target); })); break; default: this.attachListener(el, directive, component); } }, attachListener(el, directive, component, callback) { const _this2 = this; directive.modifiers.includes('prefetch') && el.addEventListener('mouseenter', (() => { component.addPrefetchAction(new _default$4(directive.method, directive.params, el)); })); const event = directive.type; const debouncedHandler = (function (condition, callback, time) { return condition ? debounce(callback, time) : callback; }(directive.modifiers.includes('debounce'), ((e) => { callback && !1 === callback(e) || component.callAfterModelDebounce((() => { const el = e.target; directive.setEventContext(e), _this2.preventAndStop(e, directive.modifiers); let _component$scopedList; const { method } = directive; const { params } = directive; if (params.length === 0 && e instanceof CustomEvent && e.detail && params.push(e.detail), method === '$emit') return (_component$scopedList = component.scopedListeners).call.apply(_component$scopedList, _toConsumableArray(params)), void store$2.emit.apply(store$2, _toConsumableArray(params)); method !== '$emitUp' ? method !== '$emitSelf' ? method !== '$emitTo' ? directive.value && component.addAction(new _default$4(method, params, el)) : store$2.emitTo.apply(store$2, _toConsumableArray(params)) : store$2.emitSelf.apply(store$2, [component.id].concat(_toConsumableArray(params))) : store$2.emitUp.apply(store$2, [el].concat(_toConsumableArray(params))); })); }), directive.durationOr(150))); el.addEventListener(event, debouncedHandler), component.addListenerForTeardown((() => { el.removeEventListener(event, debouncedHandler); })); }, preventAndStop(event, modifiers) { modifiers.includes('prevent') && event.preventDefault(), modifiers.includes('stop') && event.stopPropagation(); },
  }; const PrefetchManager = (function () { function PrefetchManager(component) { _classCallCheck(this, PrefetchManager), this.component = component, this.prefetchMessagesByActionId = {}; } return _createClass(PrefetchManager, [{ key: 'addMessage', value(message) { this.prefetchMessagesByActionId[message.prefetchId] = message; } }, { key: 'actionHasPrefetch', value(action) { return Object.keys(this.prefetchMessagesByActionId).includes(action.toId()); } }, { key: 'actionPrefetchResponseHasBeenReceived', value(action) { return !!this.getPrefetchMessageByAction(action).response; } }, { key: 'getPrefetchMessageByAction', value(action) { return this.prefetchMessagesByActionId[action.toId()]; } }, { key: 'clearPrefetches', value() { this.prefetchMessagesByActionId = {}; } }]), PrefetchManager; }()); function LoadingStates() { store$2.registerHook('component.initialized', ((component) => { component.targetedLoadingElsByAction = {}, component.genericLoadingEls = [], component.currentlyActiveLoadingEls = [], component.currentlyActiveUploadLoadingEls = []; })), store$2.registerHook('element.initialized', ((el, component) => { const directives = wireDirectives(el); directives.missing('loading') || directives.directives.filter(((i) => i.type === 'loading')).forEach(((directive) => { processLoadingDirective(component, el, directive); })); })), store$2.registerHook('message.sent', ((message, component) => { const actions = message.updateQueue.filter(((action) => action.type === 'callMethod')).map(((action) => action.payload.method)); const actionsWithParams = message.updateQueue.filter(((action) => action.type === 'callMethod')).map(((action) => generateSignatureFromMethodAndParams(action.payload.method, action.payload.params))); const models = message.updateQueue.filter(((action) => action.type === 'syncInput')).map(((action) => { const { name } = action.payload; if (!name.includes('.')) return name; const modelActions = []; return modelActions.push(name.split('.').reduce(((fullAction, part) => (modelActions.push(fullAction), `${fullAction}.${part}`)))), modelActions; })).flat(); setLoading(component, actions.concat(actionsWithParams).concat(models)); })), store$2.registerHook('message.failed', ((message, component) => { unsetLoading(component); })), store$2.registerHook('message.received', ((message, component) => { unsetLoading(component); })), store$2.registerHook('element.removed', ((el, component) => { removeLoadingEl(component, el); })); } function processLoadingDirective(component, el, directive) { el.__livewire_on_finish_loading = []; let actionNames = !1; const directives = wireDirectives(el); if (directives.get('target')) { const target = directives.get('target'); actionNames = target.params.length > 0 ? [generateSignatureFromMethodAndParams(target.method, target.params)] : target.value.split(',').map(((s) => s.trim())); } else { const nonActionOrModelLivewireDirectives = ['init', 'dirty', 'offline', 'target', 'loading', 'poll', 'ignore', 'key', 'id']; (actionNames = directives.all().filter(((i) => !nonActionOrModelLivewireDirectives.includes(i.type))).map(((i) => i.method))).length < 1 && (actionNames = !1); }addLoadingEl(component, el, directive, actionNames); } function addLoadingEl(component, el, directive, actionsNames) { actionsNames ? actionsNames.forEach(((actionsName) => { component.targetedLoadingElsByAction[actionsName] ? component.targetedLoadingElsByAction[actionsName].push({ el, directive }) : component.targetedLoadingElsByAction[actionsName] = [{ el, directive }]; })) : component.genericLoadingEls.push({ el, directive }); } function removeLoadingEl(component, el) { component.genericLoadingEls.forEach(((element, index) => { element.el.isSameNode(el) && component.genericLoadingEls.splice(index, 1); })), Object.keys(component.targetedLoadingElsByAction).forEach(((key) => { component.targetedLoadingElsByAction[key] = component.targetedLoadingElsByAction[key].filter(((element) => !element.el.isSameNode(el))); })); } function setLoading(component, actions) { const actionTargetedEls = actions.map(((action) => component.targetedLoadingElsByAction[action])).filter(((el) => el)).flat(); const allEls = removeDuplicates(component.genericLoadingEls.concat(actionTargetedEls)); startLoading(allEls), component.currentlyActiveLoadingEls = allEls; } function setUploadLoading(component, modelName) { const actionTargetedEls = component.targetedLoadingElsByAction[modelName] || []; const allEls = removeDuplicates(component.genericLoadingEls.concat(actionTargetedEls)); startLoading(allEls), component.currentlyActiveUploadLoadingEls = allEls; } function unsetUploadLoading(component) { endLoading(component.currentlyActiveUploadLoadingEls), component.currentlyActiveUploadLoadingEls = []; } function unsetLoading(component) { endLoading(component.currentlyActiveLoadingEls), component.currentlyActiveLoadingEls = []; } function startLoading(els) {
    els.forEach(((_ref) => {
      const { el } = _ref; const
        { directive } = _ref; if (directive.modifiers.includes('class')) { const classes = directive.value.split(' ').filter(Boolean); doAndSetCallbackOnElToUndo(el, directive, (() => { let _el$classList; return (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(classes)); }), (() => { let _el$classList2; return (_el$classList2 = el.classList).remove.apply(_el$classList2, _toConsumableArray(classes)); })); } else if (directive.modifiers.includes('attr'))doAndSetCallbackOnElToUndo(el, directive, (() => el.setAttribute(directive.value, !0)), (() => el.removeAttribute(directive.value))); else { const cache = window.getComputedStyle(el, null).getPropertyValue('display'); doAndSetCallbackOnElToUndo(el, directive, (() => { el.style.display = directive.modifiers.includes('remove') ? cache : getDisplayProperty(directive); }), (() => { el.style.display = 'none'; })); }
    }));
  } function getDisplayProperty(directive) { return ['inline', 'block', 'table', 'flex', 'grid', 'inline-flex'].filter(((i) => directive.modifiers.includes(i)))[0] || 'inline-block'; } function doAndSetCallbackOnElToUndo(el, directive, doCallback, undoCallback) {
    if (directive.modifiers.includes('remove')) { const _ref2 = [undoCallback, doCallback]; doCallback = _ref2[0], undoCallback = _ref2[1]; } if (directive.modifiers.includes('delay')) {
      let duration = 200; const delayModifiers = {
        shortest: 50, shorter: 100, short: 150, long: 300, longer: 500, longest: 1e3,
      }; Object.keys(delayModifiers).some(((key) => { if (directive.modifiers.includes(key)) return duration = delayModifiers[key], !0; })); const timeout = setTimeout((() => { doCallback(), el.__livewire_on_finish_loading.push((() => undoCallback())); }), duration); el.__livewire_on_finish_loading.push((() => clearTimeout(timeout)));
    } else doCallback(), el.__livewire_on_finish_loading.push((() => undoCallback()));
  } function endLoading(els) { els.forEach(((_ref3) => { for (let { el } = _ref3; el.__livewire_on_finish_loading.length > 0;)el.__livewire_on_finish_loading.shift()(); })); } function generateSignatureFromMethodAndParams(method, params) { return method + btoa(encodeURIComponent(params.toString())); } function removeDuplicates(arr) { return Array.from(new Set(arr)); } const MessageBag = (function () { function MessageBag() { _classCallCheck(this, MessageBag), this.bag = {}; } return _createClass(MessageBag, [{ key: 'add', value(name, thing) { this.bag[name] || (this.bag[name] = []), this.bag[name].push(thing); } }, { key: 'push', value(name, thing) { this.add(name, thing); } }, { key: 'first', value(name) { return this.bag[name] ? this.bag[name][0] : null; } }, { key: 'last', value(name) { return this.bag[name].slice(-1)[0]; } }, { key: 'get', value(name) { return this.bag[name]; } }, { key: 'shift', value(name) { return this.bag[name].shift(); } }, { key: 'call', value(name) { for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)params[_key - 1] = arguments[_key]; (this.listeners[name] || []).forEach(((callback) => { callback.apply(void 0, params); })); } }, { key: 'has', value(name) { return Object.keys(this.listeners).includes(name); } }]), MessageBag; }()); const UploadManager = (function () {
    function UploadManager(component) { _classCallCheck(this, UploadManager), this.component = component, this.uploadBag = new MessageBag(), this.removeBag = new MessageBag(); } return _createClass(UploadManager, [{ key: 'registerListeners', value() { const _this = this; this.component.on('upload:generatedSignedUrl', ((name, url) => { setUploadLoading(_this.component, name), _this.handleSignedUrl(name, url); })), this.component.on('upload:generatedSignedUrlForS3', ((name, payload) => { setUploadLoading(_this.component, name), _this.handleS3PreSignedUrl(name, payload); })), this.component.on('upload:finished', ((name, tmpFilenames) => _this.markUploadFinished(name, tmpFilenames))), this.component.on('upload:errored', ((name) => _this.markUploadErrored(name))), this.component.on('upload:removed', ((name, tmpFilename) => _this.removeBag.shift(name).finishCallback(tmpFilename))); } }, {
      key: 'upload',
      value(name, file, finishCallback, errorCallback, progressCallback) {
        this.setUpload(name, {
          files: [file], multiple: !1, finishCallback, errorCallback, progressCallback,
        });
      },
    }, {
      key: 'uploadMultiple',
      value(name, files, finishCallback, errorCallback, progressCallback) {
        this.setUpload(name, {
          files: Array.from(files), multiple: !0, finishCallback, errorCallback, progressCallback,
        });
      },
    }, { key: 'removeUpload', value(name, tmpFilename, finishCallback) { this.removeBag.push(name, { tmpFilename, finishCallback }), this.component.call('removeUpload', name, tmpFilename); } }, { key: 'setUpload', value(name, uploadObject) { this.uploadBag.add(name, uploadObject), this.uploadBag.get(name).length === 1 && this.startUpload(name, uploadObject); } }, { key: 'handleSignedUrl', value(name, url) { const formData = new FormData(); Array.from(this.uploadBag.first(name).files).forEach(((file) => formData.append('files[]', file))); const headers = { Accept: 'application/json' }; const csrfToken = getCsrfToken(); csrfToken && (headers['X-CSRF-TOKEN'] = csrfToken), this.makeRequest(name, formData, 'post', url, headers, ((response) => response.paths)); } }, { key: 'handleS3PreSignedUrl', value(name, payload) { const formData = this.uploadBag.first(name).files[0]; const { headers } = payload; 'Host' in headers && delete headers.Host; const { url } = payload; this.makeRequest(name, formData, 'put', url, headers, ((response) => [payload.path])); } }, { key: 'makeRequest', value(name, formData, method, url, headers, retrievePaths) { const _this2 = this; const request = new XMLHttpRequest(); request.open(method, url), Object.entries(headers).forEach(((_ref) => { const _ref2 = _slicedToArray(_ref, 2); const key = _ref2[0]; const value = _ref2[1]; request.setRequestHeader(key, value); })), request.upload.addEventListener('progress', ((e) => { e.detail = {}, e.detail.progress = Math.round(100 * e.loaded / e.total), _this2.uploadBag.first(name).progressCallback(e); })), request.addEventListener('load', (() => { if ((`${request.status}`)[0] !== '2') { let errors = null; request.status === 422 && (errors = request.response), _this2.component.call('uploadErrored', name, errors, _this2.uploadBag.first(name).multiple); } else { const paths = retrievePaths(request.response && JSON.parse(request.response)); _this2.component.call('finishUpload', name, paths, _this2.uploadBag.first(name).multiple); } })), request.send(formData); } }, { key: 'startUpload', value(name, uploadObject) { const fileInfos = uploadObject.files.map(((file) => ({ name: file.name, size: file.size, type: file.type }))); this.component.call('startUpload', name, fileInfos, uploadObject.multiple), setUploadLoading(this.component, name); } }, { key: 'markUploadFinished', value(name, tmpFilenames) { unsetUploadLoading(this.component); const uploadObject = this.uploadBag.shift(name); uploadObject.finishCallback(uploadObject.multiple ? tmpFilenames : tmpFilenames[0]), this.uploadBag.get(name).length > 0 && this.startUpload(name, this.uploadBag.last(name)); } }, { key: 'markUploadErrored', value(name) { unsetUploadLoading(this.component), this.uploadBag.shift(name).errorCallback(), this.uploadBag.get(name).length > 0 && this.startUpload(name, this.uploadBag.last(name)); } }]), UploadManager;
  }()); function SupportAlpine() { window.addEventListener('livewire:load', (() => { window.Alpine && (refreshAlpineAfterEveryLivewireRequest(), addDollarSignWire(), supportEntangle()); })); } function refreshAlpineAfterEveryLivewireRequest() { isV3() ? store$2.registerHook('message.processed', ((message, livewireComponent) => { walk(livewireComponent.el, ((el) => { el._x_hidePromise || el._x_runEffects && el._x_runEffects(); })); })) : window.Alpine.onComponentInitialized && window.Alpine.onComponentInitialized(((component) => { const livewireEl = component.$el.closest('[wire\\:id]'); livewireEl && livewireEl.__livewire && store$2.registerHook('message.processed', ((message, livewireComponent) => { livewireComponent === livewireEl.__livewire && component.updateElements(component.$el); })); })); } function addDollarSignWire() { isV3() ? window.Alpine.magic('wire', ((el) => { const wireEl = el.closest('[wire\\:id]'); return wireEl || console.warn('Alpine: Cannot reference "$wire" outside a Livewire component.'), wireEl.__livewire.$wire; })) : window.Alpine.addMagicProperty && window.Alpine.addMagicProperty('wire', ((componentEl) => { const wireEl = componentEl.closest('[wire\\:id]'); return wireEl || console.warn('Alpine: Cannot reference "$wire" outside a Livewire component.'), wireEl.__livewire.$wire; })); } function supportEntangle() { isV3() || window.Alpine.onBeforeComponentInitialized && window.Alpine.onBeforeComponentInitialized(((component) => { const livewireEl = component.$el.closest('[wire\\:id]'); livewireEl && livewireEl.__livewire && Object.entries(component.unobservedData).forEach(((_ref) => { const _ref2 = _slicedToArray(_ref, 2); const key = _ref2[0]; const value = _ref2[1]; if (value && _typeof(value) === 'object' && value.livewireEntangle) { const livewireProperty = value.livewireEntangle; const { isDeferred } = value; const livewireComponent = livewireEl.__livewire; const livewirePropertyValue = livewireEl.__livewire.get(livewireProperty); if (void 0 === livewirePropertyValue) return void console.error("Livewire Entangle Error: Livewire property '".concat(livewireProperty, "' cannot be found")); component.unobservedData[key] = JSON.parse(JSON.stringify(livewirePropertyValue)); let blockAlpineWatcher = !1; component.unobservedData.$watch(key, ((value) => { !0 !== blockAlpineWatcher ? JSON.stringify(value) != JSON.stringify(livewireEl.__livewire.getPropertyValueIncludingDefers(livewireProperty)) && livewireComponent.set(livewireProperty, value, isDeferred, !isDeferred) : blockAlpineWatcher = !1; })), livewireComponent.watch(livewireProperty, ((value) => { component.$data[key] = void 0 !== value ? JSON.parse(JSON.stringify(value)) : value; })); } })); })); } function getEntangleFunction(component) { return isV3() ? function (name) { const defer = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; let isDeferred = defer; const livewireProperty = name; const livewireComponent = component; const livewirePropertyValue = component.get(livewireProperty); const interceptor = Alpine.interceptor(((initialValue, getter, setter, path, key) => { if (void 0 !== livewirePropertyValue) { const value = JSON.parse(JSON.stringify(livewirePropertyValue)); return setter(value), window.Alpine.effect((() => { const value = getter(); JSON.stringify(value) != JSON.stringify(livewireComponent.getPropertyValueIncludingDefers(livewireProperty)) && livewireComponent.set(livewireProperty, value, isDeferred, !isDeferred); })), livewireComponent.watch(livewireProperty, ((value) => { window.Alpine.disableEffectScheduling((() => { setter(void 0 !== value ? JSON.parse(JSON.stringify(value)) : value); })); })), value; }console.error("Livewire Entangle Error: Livewire property '".concat(livewireProperty, "' cannot be found")); }), ((obj) => { Object.defineProperty(obj, 'defer', { get() { return isDeferred = !0, obj; } }); })); return interceptor(livewirePropertyValue); } : function (name) { const defer = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; return { isDeferred: defer, livewireEntangle: name, get defer() { return this.isDeferred = !0, this; } }; }; } function alpinifyElementsForMorphdom(from, to) { if (isV3()) return alpinifyElementsForMorphdomV3(from, to); if (from.__x && window.Alpine.clone(from.__x, to), Array.from(from.attributes).map(((attr) => attr.name)).some(((name) => /x-show/.test(name)))) if (from.__x_transition)from.skipElUpdatingButStillUpdateChildren = !0; else if (isHiding(from, to)) { const style = to.getAttribute('style'); style && to.setAttribute('style', style.replace('display: none;', '')); } else isShowing(from, to) && (to.style.display = from.style.display); } function alpinifyElementsForMorphdomV3(from, to) { from.nodeType === 1 && from._x_dataStack && window.Alpine.clone(from, to); } function isHiding(from, to) { return beforeAlpineTwoPointSevenPointThree() ? from.style.display === '' && to.style.display === 'none' : from.__x_is_shown && !to.__x_is_shown; } function isShowing(from, to) { return beforeAlpineTwoPointSevenPointThree() ? from.style.display === 'none' && to.style.display === '' : !from.__x_is_shown && to.__x_is_shown; } function beforeAlpineTwoPointSevenPointThree() { const _window$Alpine$versio2 = _slicedToArray(window.Alpine.version.split('.').map(((i) => Number(i))), 3); const major = _window$Alpine$versio2[0]; const minor = _window$Alpine$versio2[1]; const patch = _window$Alpine$versio2[2]; return major <= 2 && minor <= 7 && patch <= 2; } function isV3() { return window.Alpine && window.Alpine.version && /^3\..+\..+$/.test(window.Alpine.version); } const Component = (function () {
    function Component(el, connection) { _classCallCheck(this, Component), el.__livewire = this, this.el = el, this.lastFreshHtml = this.el.outerHTML, this.id = this.el.getAttribute('wire:id'), this.checkForMultipleRootElements(), this.connection = connection; const initialData = JSON.parse(this.el.getAttribute('wire:initial-data')); if (this.el.removeAttribute('wire:initial-data'), this.fingerprint = initialData.fingerprint, this.serverMemo = initialData.serverMemo, this.effects = initialData.effects, this.listeners = this.effects.listeners, this.updateQueue = [], this.deferredActions = {}, this.tearDownCallbacks = [], this.messageInTransit = void 0, this.scopedListeners = new MessageBus(), this.prefetchManager = new PrefetchManager(this), this.uploadManager = new UploadManager(this), this.watchers = {}, store$2.callHook('component.initialized', this), this.initialize(), this.uploadManager.registerListeners(), this.effects.redirect) return this.redirect(this.effects.redirect); } return _createClass(Component, [{ key: 'name', get() { return this.fingerprint.name; } }, { key: 'data', get() { return this.serverMemo.data; } }, { key: 'childIds', get() { return Object.values(this.serverMemo.children).map(((child) => child.id)); } }, { key: 'checkForMultipleRootElements', value() { const _this = this; (function countElementsBeforeMarker(el) { const carryCount = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; if (!el) return carryCount; if (el.nodeType === Node.COMMENT_NODE && el.textContent.includes('wire-end:'.concat(_this.id))) return carryCount; const newlyDiscoveredEls = el.nodeType === Node.ELEMENT_NODE ? 1 : 0; return countElementsBeforeMarker(el.nextSibling, carryCount + newlyDiscoveredEls); }(this.el.nextSibling)) > 0 && console.warn('Livewire: Multiple root elements detected. This is not supported. See docs for more information https://laravel-livewire.com/docs/2.x/rendering-components#returning-blade', this.el); } }, { key: 'initialize', value() { const _this2 = this; this.walk(((el) => nodeInitializer.initialize(el, _this2)), ((el) => store$2.addComponent(new Component(el, _this2.connection)))); } }, { key: 'get', value(name) { return name.split('.').reduce(((carry, segment) => (void 0 === carry ? carry : carry[segment])), this.data); } }, { key: 'getPropertyValueIncludingDefers', value(name) { const action = this.deferredActions[name]; return action ? action.payload.value : this.get(name); } }, { key: 'updateServerMemoFromResponseAndMergeBackIntoResponse', value(message) { const _this3 = this; Object.entries(message.response.serverMemo).forEach(((_ref) => { const _ref2 = _slicedToArray(_ref, 2); const key = _ref2[0]; const value = _ref2[1]; key === 'data' ? Object.entries(value || {}).forEach(((_ref3) => { const _ref4 = _slicedToArray(_ref3, 2); const dataKey = _ref4[0]; const dataValue = _ref4[1]; _this3.serverMemo.data[dataKey] = dataValue, message.shouldSkipWatcherForDataKey(dataKey) || Object.entries(_this3.watchers).forEach(((_ref5) => { const _ref6 = _slicedToArray(_ref5, 2); const key = _ref6[0]; const watchers = _ref6[1]; const originalSplitKey = key.split('.'); const basePropertyName = originalSplitKey.shift(); const restOfPropertyName = originalSplitKey.join('.'); if (basePropertyName == dataKey) { const potentiallyNestedValue = restOfPropertyName ? getValue(dataValue, restOfPropertyName) : dataValue; watchers.forEach(((watcher) => watcher(potentiallyNestedValue))); } })); })) : _this3.serverMemo[key] = value; })), message.response.serverMemo = { ...this.serverMemo }; } }, { key: 'watch', value(name, callback) { this.watchers[name] || (this.watchers[name] = []), this.watchers[name].push(callback); } }, { key: 'set', value(name, value) { const defer = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const skipWatcher = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; defer ? this.addAction(new _default(name, value, this.el, skipWatcher)) : this.addAction(new _default$4('$set', [name, value], this.el, skipWatcher)); } }, { key: 'sync', value(name, value) { const defer = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; defer ? this.addAction(new _default(name, value, this.el)) : this.addAction(new _default$1(name, value, this.el)); } }, { key: 'call', value(method) { for (var _this4 = this, _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)params[_key - 1] = arguments[_key]; return new Promise(((resolve, reject) => { const action = new _default$4(method, params, _this4.el); _this4.addAction(action), action.onResolve(((thing) => resolve(thing))), action.onReject(((thing) => reject(thing))); })); } }, { key: 'on', value(event, callback) { this.scopedListeners.register(event, callback); } }, { key: 'addAction', value(action) { if (action instanceof _default) this.deferredActions[action.name] = action; else { if (this.prefetchManager.actionHasPrefetch(action) && this.prefetchManager.actionPrefetchResponseHasBeenReceived(action)) { const message = this.prefetchManager.getPrefetchMessageByAction(action); return this.handleResponse(message), void this.prefetchManager.clearPrefetches(); } this.updateQueue.push(action), debounce(this.fireMessage, 5).apply(this), this.prefetchManager.clearPrefetches(); } } }, { key: 'fireMessage', value() { const _this5 = this; if (!this.messageInTransit) { Object.entries(this.deferredActions).forEach(((_ref7) => { const _ref8 = _slicedToArray(_ref7, 2); _ref8[0]; const action = _ref8[1]; _this5.updateQueue.unshift(action); })), this.deferredActions = {}, this.messageInTransit = new _default$3(this, this.updateQueue); const sendMessage = function () { _this5.connection.sendMessage(_this5.messageInTransit), store$2.callHook('message.sent', _this5.messageInTransit, _this5), _this5.updateQueue = []; }; window.capturedRequestsForDusk ? window.capturedRequestsForDusk.push(sendMessage) : sendMessage(); } } }, { key: 'messageSendFailed', value() { store$2.callHook('message.failed', this.messageInTransit, this), this.messageInTransit.reject(), this.messageInTransit = null; } }, { key: 'receiveMessage', value(message, payload) { message.storeResponse(payload), message instanceof _default$2 || (this.handleResponse(message), this.updateQueue.length > 0 && this.fireMessage(), dispatch('livewire:update')); } }, { key: 'handleResponse', value(message) { const _this6 = this; const { response } = message; this.updateServerMemoFromResponseAndMergeBackIntoResponse(message), store$2.callHook('message.received', message, this), response.effects.html ? (this.lastFreshHtml = response.effects.html, this.handleMorph(response.effects.html.trim())) : this.handleMorph(this.lastFreshHtml), response.effects.dirty && this.forceRefreshDataBoundElementsMarkedAsDirty(response.effects.dirty), message.replaying || (this.messageInTransit && this.messageInTransit.resolve(), this.messageInTransit = null, response.effects.emits && response.effects.emits.length > 0 && response.effects.emits.forEach(((event) => { let _this6$scopedListener; (_this6$scopedListener = _this6.scopedListeners).call.apply(_this6$scopedListener, [event.event].concat(_toConsumableArray(event.params))), event.selfOnly ? store$2.emitSelf.apply(store$2, [_this6.id, event.event].concat(_toConsumableArray(event.params))) : event.to ? store$2.emitTo.apply(store$2, [event.to, event.event].concat(_toConsumableArray(event.params))) : event.ancestorsOnly ? store$2.emitUp.apply(store$2, [_this6.el, event.event].concat(_toConsumableArray(event.params))) : store$2.emit.apply(store$2, [event.event].concat(_toConsumableArray(event.params))); })), response.effects.dispatches && response.effects.dispatches.length > 0 && response.effects.dispatches.forEach(((event) => { const data = event.data ? event.data : {}; const e = new CustomEvent(event.event, { bubbles: !0, detail: data }); _this6.el.dispatchEvent(e); }))), store$2.callHook('message.processed', message, this), response.effects.redirect && setTimeout((() => _this6.redirect(response.effects.redirect))); } }, { key: 'redirect', value(url) { window.Turbolinks && window.Turbolinks.supported ? window.Turbolinks.visit(url) : window.location.href = url; } }, { key: 'forceRefreshDataBoundElementsMarkedAsDirty', value(dirtyInputs) { const _this7 = this; this.walk(((el) => { const directives = wireDirectives(el); if (!directives.missing('model')) { const modelValue = directives.get('model').value; DOM.hasFocus(el) && !dirtyInputs.includes(modelValue) || DOM.setInputValueFromModel(el, _this7); } })); } }, { key: 'addPrefetchAction', value(action) { if (!this.prefetchManager.actionHasPrefetch(action)) { const message = new _default$2(this, action); this.prefetchManager.addMessage(message), this.connection.sendMessage(message); } } }, {
      key: 'handleMorph',
      value(dom) {
        const _this8 = this; this.morphChanges = { changed: [], added: [], removed: [] }, morphdom(this.el, dom, {
          childrenOnly: !1, getNodeKey(node) { return node.hasAttribute('wire:key') ? node.getAttribute('wire:key') : node.hasAttribute('wire:id') ? node.getAttribute('wire:id') : node.id; }, onBeforeNodeAdded(node) {}, onBeforeNodeDiscarded(node) { if (node.__x_inserted_me && Array.from(node.attributes).some(((attr) => /x-transition/.test(attr.name)))) return !1; }, onNodeDiscarded(node) { store$2.callHook('element.removed', node, _this8), node.__livewire && store$2.removeComponent(node.__livewire), _this8.morphChanges.removed.push(node); }, onBeforeElChildrenUpdated(node) {}, onBeforeElUpdated(from, to) { if (from.isEqualNode(to)) return !1; store$2.callHook('element.updating', from, to, _this8), from.hasAttribute('wire:model') && from.tagName.toUpperCase() === 'SELECT' && (to.selectedIndex = -1); const fromDirectives = wireDirectives(from); if (fromDirectives.has('ignore') || !0 === from.__livewire_ignore || !0 === from.__livewire_ignore_self) { if (!(fromDirectives.has('ignore') && fromDirectives.get('ignore').modifiers.includes('self') || !0 === from.__livewire_ignore_self)) return !1; from.skipElUpdatingButStillUpdateChildren = !0; } if (DOM.isComponentRootEl(from) && from.getAttribute('wire:id') !== _this8.id) return !1; DOM.isComponentRootEl(from) && (to.__livewire = _this8), alpinifyElementsForMorphdom(from, to); }, onElUpdated(node) { _this8.morphChanges.changed.push(node), store$2.callHook('element.updated', node, _this8); }, onNodeAdded(node) { if (DOM.closestRoot(node).getAttribute('wire:id') === _this8.id) { if (!1 === nodeInitializer.initialize(node, _this8)) return !1; } else DOM.isComponentRootEl(node) && (store$2.addComponent(new Component(node, _this8.connection)), node.skipAddingChildren = !0); _this8.morphChanges.added.push(node); },
        }), window.skipShow = !1;
      },
    }, { key: 'walk', value(callback) { const _this9 = this; const callbackWhenNewComponentIsEncountered = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function (el) {}; walk(this.el, ((el) => { if (!el.isSameNode(_this9.el)) return el.hasAttribute('wire:id') ? (callbackWhenNewComponentIsEncountered(el), !1) : !1 !== callback(el) && void 0; callback(el); })); } }, { key: 'modelSyncDebounce', value(callback, time) { this.modelDebounceCallbacks || (this.modelDebounceCallbacks = []); let timeout; const callbackRegister = { callback() {} }; return this.modelDebounceCallbacks.push(callbackRegister), function (e) { clearTimeout(timeout), timeout = setTimeout((() => { callback(e), timeout = void 0, callbackRegister.callback = function () {}; }), time), callbackRegister.callback = function () { clearTimeout(timeout), callback(e); }; }; } }, { key: 'callAfterModelDebounce', value(callback) { this.modelDebounceCallbacks && this.modelDebounceCallbacks.forEach(((callbackRegister) => { callbackRegister.callback(), callbackRegister.callback = function () {}; })), callback(); } }, { key: 'addListenerForTeardown', value(teardownCallback) { this.tearDownCallbacks.push(teardownCallback); } }, { key: 'tearDown', value() { this.tearDownCallbacks.forEach(((callback) => callback())); } }, { key: 'upload', value(name, file) { const finishCallback = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {}; const errorCallback = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {}; const progressCallback = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : function () {}; this.uploadManager.upload(name, file, finishCallback, errorCallback, progressCallback); } }, { key: 'uploadMultiple', value(name, files) { const finishCallback = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {}; const errorCallback = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {}; const progressCallback = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : function () {}; this.uploadManager.uploadMultiple(name, files, finishCallback, errorCallback, progressCallback); } }, { key: 'removeUpload', value(name, tmpFilename) { const finishCallback = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {}; const errorCallback = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {}; this.uploadManager.removeUpload(name, tmpFilename, finishCallback, errorCallback); } }, { key: '$wire', get() { if (this.dollarWireProxy) return this.dollarWireProxy; const component = this; return this.dollarWireProxy = new Proxy({}, { get(object, property) { if (!['_x_interceptor'].includes(property)) { if (property === 'entangle') return getEntangleFunction(component); if (property === '__instance') return component; if (typeof property === 'string' && property.match(/^emit.*/)) return function () { for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2]; return property === 'emitSelf' ? store$2.emitSelf.apply(store$2, [component.id].concat(args)) : property === 'emitUp' ? store$2.emitUp.apply(store$2, [component.el].concat(args)) : store$2[property].apply(store$2, args); }; if (['get', 'set', 'sync', 'call', 'on', 'upload', 'uploadMultiple', 'removeUpload'].includes(property)) return function () { for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)args[_key3] = arguments[_key3]; return component[property].apply(component, args); }; const getResult = component.get(property); return void 0 === getResult ? function () { for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)args[_key4] = arguments[_key4]; return component.call.apply(component, [property].concat(args)); } : getResult; } }, set(obj, prop, value) { return component.set(prop, value), !0; } }); } }]), Component;
  }()); function FileUploads() { store$2.registerHook('interceptWireModelAttachListener', ((directive, el, component) => { if (el.tagName.toLowerCase() === 'input' && el.type === 'file') { const finish = function () { return el.dispatchEvent(new CustomEvent('livewire-upload-finish', { bubbles: !0 })); }; const error = function () { return el.dispatchEvent(new CustomEvent('livewire-upload-error', { bubbles: !0 })); }; const progress = function (progressEvent) { const percentCompleted = Math.round(100 * progressEvent.loaded / progressEvent.total); el.dispatchEvent(new CustomEvent('livewire-upload-progress', { bubbles: !0, detail: { progress: percentCompleted } })); }; const eventHandler = function (e) { e.target.files.length !== 0 && (el.dispatchEvent(new CustomEvent('livewire-upload-start', { bubbles: !0 })), e.target.multiple ? component.uploadMultiple(directive.value, e.target.files, finish, error, progress) : component.upload(directive.value, e.target.files[0], finish, error, progress)); }; el.addEventListener('change', eventHandler); const clearFileInputValue = function () { el.value = null; }; el.addEventListener('click', clearFileInputValue), component.addListenerForTeardown((() => { el.removeEventListener('change', eventHandler), el.removeEventListener('click', clearFileInputValue); })); } })); } function LaravelEcho() { store$2.registerHook('component.initialized', ((component) => { Array.isArray(component.listeners) && component.listeners.forEach(((event) => { if (event.startsWith('echo')) { if (typeof Echo === 'undefined') return void console.warn('Laravel Echo cannot be found'); const event_parts = event.split(/(echo:|echo-)|:|,/); event_parts[1] == 'echo:' && event_parts.splice(2, 0, 'channel', void 0), event_parts[2] == 'notification' && event_parts.push(void 0, void 0); const _event_parts = _slicedToArray(event_parts, 7); _event_parts[0], _event_parts[1]; const channel_type = _event_parts[2]; _event_parts[3]; const channel = _event_parts[4]; _event_parts[5]; const event_name = _event_parts[6]; ['channel', 'private', 'encryptedPrivate'].includes(channel_type) ? Echo[channel_type](channel).listen(event_name, ((e) => { store$2.emit(event, e); })) : channel_type == 'presence' ? Echo.join(channel)[event_name](((e) => { store$2.emit(event, e); })) : channel_type == 'notification' ? Echo.private(channel).notification(((notification) => { store$2.emit(event, notification); })) : console.warn('Echo channel type not yet supported'); } })); })); } function DirtyStates() { store$2.registerHook('component.initialized', ((component) => { component.dirtyEls = []; })), store$2.registerHook('element.initialized', ((el, component) => { wireDirectives(el).missing('dirty') || component.dirtyEls.push(el); })), store$2.registerHook('interceptWireModelAttachListener', ((directive, el, component) => { const property = directive.value; el.addEventListener('input', (() => { component.dirtyEls.forEach(((dirtyEl) => { const directives = wireDirectives(dirtyEl); (directives.has('model') && directives.get('model').value === property || directives.has('target') && directives.get('target').value.split(',').map(((s) => s.trim())).includes(property)) && setDirtyState(dirtyEl, DOM.valueFromInput(el, component) != component.get(property)); })); })); })), store$2.registerHook('message.received', ((message, component) => { component.dirtyEls.forEach(((element) => { element.__livewire_dirty_cleanup && (element.__livewire_dirty_cleanup(), delete element.__livewire_dirty_cleanup); })); })), store$2.registerHook('element.removed', ((el, component) => { component.dirtyEls.forEach(((element, index) => { element.isSameNode(el) && component.dirtyEls.splice(index, 1); })); })); } function setDirtyState(el, isDirty) { const directive = wireDirectives(el).get('dirty'); if (directive.modifiers.includes('class')) { let _el$classList; let _el$classList3; const classes = directive.value.split(' '); if (directive.modifiers.includes('remove') !== isDirty)(_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(classes)), el.__livewire_dirty_cleanup = function () { let _el$classList2; return (_el$classList2 = el.classList).remove.apply(_el$classList2, _toConsumableArray(classes)); }; else (_el$classList3 = el.classList).remove.apply(_el$classList3, _toConsumableArray(classes)), el.__livewire_dirty_cleanup = function () { let _el$classList4; return (_el$classList4 = el.classList).add.apply(_el$classList4, _toConsumableArray(classes)); }; } else directive.modifiers.includes('attr') ? directive.modifiers.includes('remove') !== isDirty ? (el.setAttribute(directive.value, !0), el.__livewire_dirty_cleanup = function () { return el.removeAttribute(directive.value); }) : (el.removeAttribute(directive.value), el.__livewire_dirty_cleanup = function () { return el.setAttribute(directive.value, !0); }) : wireDirectives(el).get('model') || (el.style.display = isDirty ? 'inline-block' : 'none', el.__livewire_dirty_cleanup = function () { return el.style.display = isDirty ? 'none' : 'inline-block'; }); } const cleanupStackByComponentId = {}; function DisableForms() { store$2.registerHook('element.initialized', ((el, component) => { wireDirectives(el).missing('submit') || el.addEventListener('submit', (() => { cleanupStackByComponentId[component.id] = [], component.walk(((node) => { if (el.contains(node)) return !node.hasAttribute('wire:ignore') && void (node.tagName.toLowerCase() === 'button' && node.type === 'submit' || node.tagName.toLowerCase() === 'select' || node.tagName.toLowerCase() === 'input' && (node.type === 'checkbox' || node.type === 'radio') ? (node.disabled || cleanupStackByComponentId[component.id].push((() => node.disabled = !1)), node.disabled = !0) : node.tagName.toLowerCase() !== 'input' && node.tagName.toLowerCase() !== 'textarea' || (node.readOnly || cleanupStackByComponentId[component.id].push((() => node.readOnly = !1)), node.readOnly = !0)); })); })); })), store$2.registerHook('message.failed', ((message, component) => cleanup(component))), store$2.registerHook('message.received', ((message, component) => cleanup(component))); } function cleanup(component) { if (cleanupStackByComponentId[component.id]) for (;cleanupStackByComponentId[component.id].length > 0;)cleanupStackByComponentId[component.id].shift()(); } function FileDownloads() { store$2.registerHook('message.received', ((message, component) => { const { response } = message; if (response.effects.download) { const urlObject = window.webkitURL || window.URL; const url = urlObject.createObjectURL(base64toBlob(response.effects.download.content, response.effects.download.contentType)); const invisibleLink = document.createElement('a'); invisibleLink.style.display = 'none', invisibleLink.href = url, invisibleLink.download = response.effects.download.name, document.body.appendChild(invisibleLink), invisibleLink.click(), setTimeout((() => { urlObject.revokeObjectURL(url); }), 0); } })); } function base64toBlob(b64Data) { let contentType = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ''; const sliceSize = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 512; const byteCharacters = atob(b64Data); const byteArrays = []; contentType === null && (contentType = ''); for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) { for (var slice = byteCharacters.slice(offset, offset + sliceSize), byteNumbers = new Array(slice.length), i = 0; i < slice.length; i++)byteNumbers[i] = slice.charCodeAt(i); const byteArray = new Uint8Array(byteNumbers); byteArrays.push(byteArray); } return new Blob(byteArrays, { type: contentType }); } let offlineEls = []; function OfflineStates() { store$2.registerHook('element.initialized', ((el) => { wireDirectives(el).missing('offline') || offlineEls.push(el); })), window.addEventListener('offline', (() => { store$2.livewireIsOffline = !0, offlineEls.forEach(((el) => { toggleOffline(el, !0); })); })), window.addEventListener('online', (() => { store$2.livewireIsOffline = !1, offlineEls.forEach(((el) => { toggleOffline(el, !1); })); })), store$2.registerHook('element.removed', ((el) => { offlineEls = offlineEls.filter(((el) => !el.isSameNode(el))); })); } function toggleOffline(el, isOffline) { const directives = wireDirectives(el); const directive = directives.get('offline'); if (directive.modifiers.includes('class')) { let _el$classList; let _el$classList2; const classes = directive.value.split(' '); if (directive.modifiers.includes('remove') !== isOffline)(_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(classes)); else (_el$classList2 = el.classList).remove.apply(_el$classList2, _toConsumableArray(classes)); } else directive.modifiers.includes('attr') ? directive.modifiers.includes('remove') !== isOffline ? el.setAttribute(directive.value, !0) : el.removeAttribute(directive.value) : directives.get('model') || (el.style.display = isOffline ? 'inline-block' : 'none'); } function SyncBrowserHistory() {
    let initializedPath = !1; const componentIdsThatAreWritingToHistoryState = new Set(); function normalizeResponse(response, component) { response.effects.dirty = Object.keys(response.serverMemo.data), response.effects.html = component.lastFreshHtml; } function onlyChangeThePathAndQueryString(url) { if (url) { const destination = new URL(url); const afterOrigin = destination.href.replace(destination.origin, '').replace(/\?$/, ''); return window.location.origin + afterOrigin + window.location.hash; } }LivewireStateManager.clearState(), store$2.registerHook('component.initialized', ((component) => { component.effects.path && setTimeout((() => { const url = onlyChangeThePathAndQueryString(initializedPath ? void 0 : component.effects.path); const response = { serverMemo: component.serverMemo, effects: component.effects }; normalizeResponse(response, component), LivewireStateManager.replaceState(url, response, component), componentIdsThatAreWritingToHistoryState.add(component.id), initializedPath = !0; })); })), store$2.registerHook('message.processed', ((message, component) => {
      if (!message.replaying) {
        const { response } = message; const
          effects = response.effects || {}; if (normalizeResponse(response, component), 'path' in effects && effects.path !== window.location.href) { const url = onlyChangeThePathAndQueryString(effects.path); LivewireStateManager.pushState(url, response, component), componentIdsThatAreWritingToHistoryState.add(component.id); } else componentIdsThatAreWritingToHistoryState.has(component.id) && LivewireStateManager.replaceState(window.location.href, response, component);
      }
    })), window.addEventListener('popstate', ((event) => { LivewireStateManager.missingState(event) || LivewireStateManager.replayResponses(event, ((response, component) => { const message = new _default$3(component, []); message.storeResponse(response), message.replaying = !0, component.handleResponse(message); })); })), store$2.registerHook('element.updating', ((from, to, component) => { from.getAttribute('wire:id') === component.id && (component.lastKnownDomId = component.id); })), store$2.registerHook('element.updated', ((node, component) => { component.lastKnownDomId && (node.getAttribute('wire:id') !== component.lastKnownDomId && store$2.changeComponentId(component, node.getAttribute('wire:id')), delete component.lastKnownDomId); }));
  } var LivewireStateManager = {
    replaceState(url, response, component) { this.updateState('replaceState', url, response, component); }, pushState(url, response, component) { this.updateState('pushState', url, response, component); }, updateState(method, url, response, component) { const state = this.currentState(); state.storeResponse(response, component); let subject; const stateArray = state.toStateArray(); const fullstateObject = Object.assign(history.state || {}, { livewire: stateArray }); store$2.callHook(`before${(subject = method).charAt(0).toUpperCase() + subject.slice(1)}`, fullstateObject, url, component); try { decodeURI(url) != 'undefined' && (url = decodeURI(url).replaceAll(' ', '+').replaceAll('\\', '%5C')), history[method](fullstateObject, '', url); } catch (error) { if (error.name === 'NS_ERROR_ILLEGAL_VALUE') { const key = this.storeInSession(stateArray); fullstateObject.livewire = key, history[method](fullstateObject, '', url); } } }, replayResponses(event, callback) { event.state.livewire && (typeof event.state.livewire === 'string' ? new LivewireState(this.getFromSession(event.state.livewire)) : new LivewireState(event.state.livewire)).replayResponses(callback); }, currentState() { return history.state && history.state.livewire ? typeof history.state.livewire === 'string' ? new LivewireState(this.getFromSession(history.state.livewire)) : new LivewireState(history.state.livewire) : new LivewireState(); }, missingState(event) { return !(event.state && event.state.livewire); }, clearState() { window.history.state && (window.history.state.livewire = (new LivewireState()).toStateArray()); }, storeInSession(value) { const key = `livewire:${(new Date()).getTime()}`; const stringifiedValue = JSON.stringify(value); return this.tryToStoreInSession(key, stringifiedValue), key; }, tryToStoreInSession(key, value) { try { sessionStorage.setItem(key, value); } catch (error) { if (![22, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14].includes(error.code)) return; const oldestTimestamp = Object.keys(sessionStorage).map(((key) => Number(key.replace('livewire:', '')))).sort().shift(); if (!oldestTimestamp) return; sessionStorage.removeItem(`livewire:${oldestTimestamp}`), this.tryToStoreInSession(key, value); } }, getFromSession(key) { const item = sessionStorage.getItem(key); if (item) return JSON.parse(item); },
  }; var LivewireState = (function () {
    function LivewireState() { const stateArray = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; _classCallCheck(this, LivewireState), this.items = stateArray; } return _createClass(LivewireState, [{ key: 'toStateArray', value() { return this.items; } }, { key: 'pushItemInProperOrder', value(signature, response, component) { const _this = this; const targetItem = { signature, response }; const existingIndex = this.items.findIndex(((item) => item.signature === signature)); if (existingIndex !== -1) return this.items[existingIndex] = targetItem; const closestParentId = store$2.getClosestParentId(component.id, this.componentIdsWithStoredResponses()); if (!closestParentId) return this.items.unshift(targetItem); const closestParentIndex = this.items.findIndex(((item) => { if (_this.parseSignature(item.signature).originalComponentId === closestParentId) return !0; })); this.items.splice(closestParentIndex, 0, targetItem); } }, { key: 'storeResponse', value(response, component) { const signature = this.getComponentNameBasedSignature(component); this.pushItemInProperOrder(signature, response, component); } }, {
      key: 'replayResponses',
      value(callback) {
        const _this2 = this; this.items.forEach(((_ref) => {
          const { signature } = _ref; const { response } = _ref; const
            component = _this2.findComponentBySignature(signature); component && callback(response, component);
        }));
      },
    }, { key: 'getComponentNameBasedSignature', value(component) { const componentName = component.fingerprint.name; const componentIndex = store$2.getComponentsByName(componentName).indexOf(component); return ''.concat(component.id, ':').concat(componentName, ':').concat(componentIndex); } }, { key: 'findComponentBySignature', value(signature) { const _this$parseSignature2 = this.parseSignature(signature); const { componentName } = _this$parseSignature2; const { componentIndex } = _this$parseSignature2; const sameNamedComponents = store$2.getComponentsByName(componentName); return sameNamedComponents[componentIndex] || sameNamedComponents[0] || console.warn("Livewire: couldn't find component on page: ".concat(componentName)); } }, { key: 'parseSignature', value(signature) { const _signature$split2 = _slicedToArray(signature.split(':'), 3); return { originalComponentId: _signature$split2[0], componentName: _signature$split2[1], componentIndex: _signature$split2[2] }; } }, { key: 'componentIdsWithStoredResponses', value() { const _this3 = this; return this.items.map(((_ref2) => { const { signature } = _ref2; return _this3.parseSignature(signature).originalComponentId; })); } }]), LivewireState;
  }()); function SupportStacks() {
    store$2.registerHook('message.received', ((message, component) => {
      const { response } = message; if (response.effects.forStack) {
        const updates = []; for (response.effects.forStack.forEach(((_ref) => {
          const { key } = _ref; const { stack } = _ref; const { type } = _ref; const { contents } = _ref; const startEl = document.querySelector('[livewire-stack="'.concat(stack, '"]')); const
            endEl = document.querySelector('[livewire-end-stack="'.concat(stack, '"]')); if (startEl && endEl && !keyHasAlreadyBeenAddedToTheStack(startEl, endEl, key)) { const frag = createFragment(contents); updates.push((() => { return type === 'push' ? (el = frag, endEl.parentElement.insertBefore(el, endEl)) : (function (el) { return startEl.parentElement.insertBefore(el, startEl.nextElementSibling); }(frag)); let el; })); }
        })); updates.length > 0;)updates.shift()();
      }
    }));
  } function keyHasAlreadyBeenAddedToTheStack(startEl, endEl, key) { return (function findKeyMarker(el) { if (!el.isSameNode(endEl)) return el.matches('[livewire-stack-key="'.concat(key, '"]')) ? el : findKeyMarker(el.nextElementSibling); }(startEl)); } function createFragment(html) { return document.createRange().createContextualFragment(html); } const Livewire = (function () { function Livewire() { _classCallCheck(this, Livewire), this.connection = new Connection(), this.components = store$2, this.devToolsEnabled = !1, this.onLoadCallback = function () {}; } return _createClass(Livewire, [{ key: 'first', value() { return Object.values(this.components.componentsById)[0].$wire; } }, { key: 'find', value(componentId) { return this.components.componentsById[componentId].$wire; } }, { key: 'all', value() { return Object.values(this.components.componentsById).map(((component) => component.$wire)); } }, { key: 'directive', value(name, callback) { this.components.registerDirective(name, callback); } }, { key: 'hook', value(name, callback) { this.components.registerHook(name, callback); } }, { key: 'onLoad', value(callback) { this.onLoadCallback = callback; } }, { key: 'onError', value(callback) { this.components.onErrorCallback = callback; } }, { key: 'emit', value(event) { for (var _this$components, _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)params[_key - 1] = arguments[_key]; (_this$components = this.components).emit.apply(_this$components, [event].concat(params)); } }, { key: 'emitTo', value(name, event) { for (var _this$components2, _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++)params[_key2 - 2] = arguments[_key2]; (_this$components2 = this.components).emitTo.apply(_this$components2, [name, event].concat(params)); } }, { key: 'on', value(event, callback) { this.components.on(event, callback); } }, { key: 'addHeaders', value(headers) { this.connection.headers = _objectSpread2(_objectSpread2({}, this.connection.headers), headers); } }, { key: 'devTools', value(enableDevtools) { this.devToolsEnabled = enableDevtools; } }, { key: 'restart', value() { this.stop(), this.start(); } }, { key: 'stop', value() { this.components.tearDownComponents(); } }, { key: 'start', value() { const _this = this; DOM.rootComponentElementsWithNoParents().forEach(((el) => { _this.components.addComponent(new Component(el, _this.connection)); })), this.onLoadCallback(), dispatch('livewire:load'), document.addEventListener('visibilitychange', (() => { _this.components.livewireIsInBackground = document.hidden; }), !1), this.components.initialRenderIsFinished = !0; } }, { key: 'rescan', value() { const _this2 = this; const node = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; DOM.rootComponentElementsWithNoParents(node).forEach(((el) => { const componentId = wireDirectives(el).get('id').value; _this2.components.hasComponent(componentId) || _this2.components.addComponent(new Component(el, _this2.connection)); })); } }, { key: 'onPageExpired', value(callback) { this.components.sessionHasExpiredCallback = callback; } }]), Livewire; }()); function monkeyPatchDomSetAttributeToAllowAtSymbols() { const original = Element.prototype.setAttribute; const hostDiv = document.createElement('div'); Element.prototype.setAttribute = function (name, value) { if (!name.includes('@')) return original.call(this, name, value); hostDiv.innerHTML = '<span '.concat(name, '="').concat(value, '"></span>'); const attr = hostDiv.firstElementChild.getAttributeNode(name); hostDiv.firstElementChild.removeAttributeNode(attr), this.setAttributeNode(attr); }; } return window.Livewire || (window.Livewire = Livewire), monkeyPatchDomSetAttributeToAllowAtSymbols(), SyncBrowserHistory(), SupportAlpine(), SupportStacks(), FileDownloads(), OfflineStates(), LoadingStates(), DisableForms(), FileUploads(), LaravelEcho(), DirtyStates(), Polling(), dispatch('livewire:available'), Livewire;
})));
// # sourceMappingURL=livewire.js.map
